// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `github.com/containerd/containerd/runtime/v2/task/shim.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.CreateTaskRequest)
pub struct CreateTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.bundle)
    pub bundle: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.rootfs)
    pub rootfs: ::std::vec::Vec<super::mount::Mount>,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.terminal)
    pub terminal: bool,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.stdin)
    pub stdin: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.stdout)
    pub stdout: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.stderr)
    pub stderr: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.checkpoint)
    pub checkpoint: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.parent_checkpoint)
    pub parent_checkpoint: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskRequest.options)
    pub options: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.CreateTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateTaskRequest {
    fn default() -> &'a CreateTaskRequest {
        <CreateTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateTaskRequest {
    pub fn new() -> CreateTaskRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string bundle = 2;

    pub fn bundle(&self) -> &str {
        &self.bundle
    }

    pub fn clear_bundle(&mut self) {
        self.bundle.clear();
    }

    // Param is passed by value, moved
    pub fn set_bundle(&mut self, v: ::std::string::String) {
        self.bundle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bundle(&mut self) -> &mut ::std::string::String {
        &mut self.bundle
    }

    // Take field
    pub fn take_bundle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bundle, ::std::string::String::new())
    }

    // repeated .containerd.types.Mount rootfs = 3;

    pub fn rootfs(&self) -> &[super::mount::Mount] {
        &self.rootfs
    }

    pub fn clear_rootfs(&mut self) {
        self.rootfs.clear();
    }

    // Param is passed by value, moved
    pub fn set_rootfs(&mut self, v: ::std::vec::Vec<super::mount::Mount>) {
        self.rootfs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rootfs(&mut self) -> &mut ::std::vec::Vec<super::mount::Mount> {
        &mut self.rootfs
    }

    // Take field
    pub fn take_rootfs(&mut self) -> ::std::vec::Vec<super::mount::Mount> {
        ::std::mem::replace(&mut self.rootfs, ::std::vec::Vec::new())
    }

    // bool terminal = 4;

    pub fn terminal(&self) -> bool {
        self.terminal
    }

    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }

    // string stdin = 5;

    pub fn stdin(&self) -> &str {
        &self.stdin
    }

    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::string::String) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::string::String {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdin, ::std::string::String::new())
    }

    // string stdout = 6;

    pub fn stdout(&self) -> &str {
        &self.stdout
    }

    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::string::String) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::string::String {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdout, ::std::string::String::new())
    }

    // string stderr = 7;

    pub fn stderr(&self) -> &str {
        &self.stderr
    }

    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::string::String) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::string::String {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stderr, ::std::string::String::new())
    }

    // string checkpoint = 8;

    pub fn checkpoint(&self) -> &str {
        &self.checkpoint
    }

    pub fn clear_checkpoint(&mut self) {
        self.checkpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_checkpoint(&mut self, v: ::std::string::String) {
        self.checkpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkpoint(&mut self) -> &mut ::std::string::String {
        &mut self.checkpoint
    }

    // Take field
    pub fn take_checkpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.checkpoint, ::std::string::String::new())
    }

    // string parent_checkpoint = 9;

    pub fn parent_checkpoint(&self) -> &str {
        &self.parent_checkpoint
    }

    pub fn clear_parent_checkpoint(&mut self) {
        self.parent_checkpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_checkpoint(&mut self, v: ::std::string::String) {
        self.parent_checkpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_checkpoint(&mut self) -> &mut ::std::string::String {
        &mut self.parent_checkpoint
    }

    // Take field
    pub fn take_parent_checkpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_checkpoint, ::std::string::String::new())
    }

    // .google.protobuf.Any options = 10;

    pub fn options(&self) -> &::protobuf::well_known_types::any::Any {
        self.options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance())
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.options = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        self.options.mut_or_insert_default()
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::well_known_types::any::Any {
        self.options.take().unwrap_or_else(|| ::protobuf::well_known_types::any::Any::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CreateTaskRequest| { &m.id },
            |m: &mut CreateTaskRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bundle",
            |m: &CreateTaskRequest| { &m.bundle },
            |m: &mut CreateTaskRequest| { &mut m.bundle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rootfs",
            |m: &CreateTaskRequest| { &m.rootfs },
            |m: &mut CreateTaskRequest| { &mut m.rootfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "terminal",
            |m: &CreateTaskRequest| { &m.terminal },
            |m: &mut CreateTaskRequest| { &mut m.terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdin",
            |m: &CreateTaskRequest| { &m.stdin },
            |m: &mut CreateTaskRequest| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdout",
            |m: &CreateTaskRequest| { &m.stdout },
            |m: &mut CreateTaskRequest| { &mut m.stdout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stderr",
            |m: &CreateTaskRequest| { &m.stderr },
            |m: &mut CreateTaskRequest| { &mut m.stderr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkpoint",
            |m: &CreateTaskRequest| { &m.checkpoint },
            |m: &mut CreateTaskRequest| { &mut m.checkpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_checkpoint",
            |m: &CreateTaskRequest| { &m.parent_checkpoint },
            |m: &mut CreateTaskRequest| { &mut m.parent_checkpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "options",
            |m: &CreateTaskRequest| { &m.options },
            |m: &mut CreateTaskRequest| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateTaskRequest>(
            "CreateTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateTaskRequest {
    const NAME: &'static str = "CreateTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.bundle = is.read_string()?;
                },
                26 => {
                    self.rootfs.push(is.read_message()?);
                },
                32 => {
                    self.terminal = is.read_bool()?;
                },
                42 => {
                    self.stdin = is.read_string()?;
                },
                50 => {
                    self.stdout = is.read_string()?;
                },
                58 => {
                    self.stderr = is.read_string()?;
                },
                66 => {
                    self.checkpoint = is.read_string()?;
                },
                74 => {
                    self.parent_checkpoint = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.bundle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bundle);
        }
        for value in &self.rootfs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.terminal != false {
            my_size += 1 + 1;
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.stdin);
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.stderr);
        }
        if !self.checkpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.checkpoint);
        }
        if !self.parent_checkpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.parent_checkpoint);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.bundle.is_empty() {
            os.write_string(2, &self.bundle)?;
        }
        for v in &self.rootfs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.terminal != false {
            os.write_bool(4, self.terminal)?;
        }
        if !self.stdin.is_empty() {
            os.write_string(5, &self.stdin)?;
        }
        if !self.stdout.is_empty() {
            os.write_string(6, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_string(7, &self.stderr)?;
        }
        if !self.checkpoint.is_empty() {
            os.write_string(8, &self.checkpoint)?;
        }
        if !self.parent_checkpoint.is_empty() {
            os.write_string(9, &self.parent_checkpoint)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateTaskRequest {
        CreateTaskRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.bundle.clear();
        self.rootfs.clear();
        self.terminal = false;
        self.stdin.clear();
        self.stdout.clear();
        self.stderr.clear();
        self.checkpoint.clear();
        self.parent_checkpoint.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateTaskRequest {
        static instance: CreateTaskRequest = CreateTaskRequest {
            id: ::std::string::String::new(),
            bundle: ::std::string::String::new(),
            rootfs: ::std::vec::Vec::new(),
            terminal: false,
            stdin: ::std::string::String::new(),
            stdout: ::std::string::String::new(),
            stderr: ::std::string::String::new(),
            checkpoint: ::std::string::String::new(),
            parent_checkpoint: ::std::string::String::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.CreateTaskResponse)
pub struct CreateTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.CreateTaskResponse.pid)
    pub pid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.CreateTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateTaskResponse {
    fn default() -> &'a CreateTaskResponse {
        <CreateTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateTaskResponse {
    pub fn new() -> CreateTaskResponse {
        ::std::default::Default::default()
    }

    // uint32 pid = 1;

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pid",
            |m: &CreateTaskResponse| { &m.pid },
            |m: &mut CreateTaskResponse| { &mut m.pid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateTaskResponse>(
            "CreateTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateTaskResponse {
    const NAME: &'static str = "CreateTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.pid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pid != 0 {
            os.write_uint32(1, self.pid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateTaskResponse {
        CreateTaskResponse::new()
    }

    fn clear(&mut self) {
        self.pid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateTaskResponse {
        static instance: CreateTaskResponse = CreateTaskResponse {
            pid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.DeleteRequest)
pub struct DeleteRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.DeleteRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.DeleteRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.DeleteRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteRequest| { &m.id },
            |m: &mut DeleteRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &DeleteRequest| { &m.exec_id },
            |m: &mut DeleteRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteRequest>(
            "DeleteRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteRequest {
    const NAME: &'static str = "DeleteRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: DeleteRequest = DeleteRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.DeleteResponse)
pub struct DeleteResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.DeleteResponse.pid)
    pub pid: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.DeleteResponse.exit_status)
    pub exit_status: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.DeleteResponse.exited_at)
    pub exited_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.DeleteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteResponse {
    fn default() -> &'a DeleteResponse {
        <DeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponse {
    pub fn new() -> DeleteResponse {
        ::std::default::Default::default()
    }

    // uint32 pid = 1;

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    // uint32 exit_status = 2;

    pub fn exit_status(&self) -> u32 {
        self.exit_status
    }

    pub fn clear_exit_status(&mut self) {
        self.exit_status = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_status(&mut self, v: u32) {
        self.exit_status = v;
    }

    // .google.protobuf.Timestamp exited_at = 3;

    pub fn exited_at(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exited_at(&mut self) {
        self.exited_at.clear();
    }

    pub fn has_exited_at(&self) -> bool {
        self.exited_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exited_at(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
        self.exited_at = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exited_at(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.mut_or_insert_default()
    }

    // Take field
    pub fn take_exited_at(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.take().unwrap_or_else(|| ::protobuf::well_known_types::timestamp::Timestamp::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pid",
            |m: &DeleteResponse| { &m.pid },
            |m: &mut DeleteResponse| { &mut m.pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exit_status",
            |m: &DeleteResponse| { &m.exit_status },
            |m: &mut DeleteResponse| { &mut m.exit_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "exited_at",
            |m: &DeleteResponse| { &m.exited_at },
            |m: &mut DeleteResponse| { &mut m.exited_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteResponse>(
            "DeleteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteResponse {
    const NAME: &'static str = "DeleteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pid = is.read_uint32()?;
                },
                16 => {
                    self.exit_status = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exited_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.pid);
        }
        if self.exit_status != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.exit_status);
        }
        if let Some(v) = self.exited_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pid != 0 {
            os.write_uint32(1, self.pid)?;
        }
        if self.exit_status != 0 {
            os.write_uint32(2, self.exit_status)?;
        }
        if let Some(v) = self.exited_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteResponse {
        DeleteResponse::new()
    }

    fn clear(&mut self) {
        self.pid = 0;
        self.exit_status = 0;
        self.exited_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteResponse {
        static instance: DeleteResponse = DeleteResponse {
            pid: 0,
            exit_status: 0,
            exited_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ExecProcessRequest)
pub struct ExecProcessRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.terminal)
    pub terminal: bool,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.stdin)
    pub stdin: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.stdout)
    pub stdout: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.stderr)
    pub stderr: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ExecProcessRequest.spec)
    pub spec: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ExecProcessRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecProcessRequest {
    fn default() -> &'a ExecProcessRequest {
        <ExecProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecProcessRequest {
    pub fn new() -> ExecProcessRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // bool terminal = 3;

    pub fn terminal(&self) -> bool {
        self.terminal
    }

    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }

    // string stdin = 4;

    pub fn stdin(&self) -> &str {
        &self.stdin
    }

    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::string::String) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::string::String {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdin, ::std::string::String::new())
    }

    // string stdout = 5;

    pub fn stdout(&self) -> &str {
        &self.stdout
    }

    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::string::String) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::string::String {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdout, ::std::string::String::new())
    }

    // string stderr = 6;

    pub fn stderr(&self) -> &str {
        &self.stderr
    }

    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::string::String) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::string::String {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stderr, ::std::string::String::new())
    }

    // .google.protobuf.Any spec = 7;

    pub fn spec(&self) -> &::protobuf::well_known_types::any::Any {
        self.spec.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ::protobuf::well_known_types::any::Any {
        self.spec.take().unwrap_or_else(|| ::protobuf::well_known_types::any::Any::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ExecProcessRequest| { &m.id },
            |m: &mut ExecProcessRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &ExecProcessRequest| { &m.exec_id },
            |m: &mut ExecProcessRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "terminal",
            |m: &ExecProcessRequest| { &m.terminal },
            |m: &mut ExecProcessRequest| { &mut m.terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdin",
            |m: &ExecProcessRequest| { &m.stdin },
            |m: &mut ExecProcessRequest| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdout",
            |m: &ExecProcessRequest| { &m.stdout },
            |m: &mut ExecProcessRequest| { &mut m.stdout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stderr",
            |m: &ExecProcessRequest| { &m.stderr },
            |m: &mut ExecProcessRequest| { &mut m.stderr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "spec",
            |m: &ExecProcessRequest| { &m.spec },
            |m: &mut ExecProcessRequest| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecProcessRequest>(
            "ExecProcessRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecProcessRequest {
    const NAME: &'static str = "ExecProcessRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.terminal = is.read_bool()?;
                },
                34 => {
                    self.stdin = is.read_string()?;
                },
                42 => {
                    self.stdout = is.read_string()?;
                },
                50 => {
                    self.stderr = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.terminal != false {
            my_size += 1 + 1;
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.stdin);
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.stderr);
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.terminal != false {
            os.write_bool(3, self.terminal)?;
        }
        if !self.stdin.is_empty() {
            os.write_string(4, &self.stdin)?;
        }
        if !self.stdout.is_empty() {
            os.write_string(5, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_string(6, &self.stderr)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecProcessRequest {
        ExecProcessRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.terminal = false;
        self.stdin.clear();
        self.stdout.clear();
        self.stderr.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecProcessRequest {
        static instance: ExecProcessRequest = ExecProcessRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            terminal: false,
            stdin: ::std::string::String::new(),
            stdout: ::std::string::String::new(),
            stderr: ::std::string::String::new(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecProcessRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecProcessRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProcessRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ExecProcessResponse)
pub struct ExecProcessResponse {
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ExecProcessResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecProcessResponse {
    fn default() -> &'a ExecProcessResponse {
        <ExecProcessResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecProcessResponse {
    pub fn new() -> ExecProcessResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecProcessResponse>(
            "ExecProcessResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecProcessResponse {
    const NAME: &'static str = "ExecProcessResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecProcessResponse {
        ExecProcessResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecProcessResponse {
        static instance: ExecProcessResponse = ExecProcessResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecProcessResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecProcessResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecProcessResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProcessResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ResizePtyRequest)
pub struct ResizePtyRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ResizePtyRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ResizePtyRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ResizePtyRequest.width)
    pub width: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.ResizePtyRequest.height)
    pub height: u32,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ResizePtyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResizePtyRequest {
    fn default() -> &'a ResizePtyRequest {
        <ResizePtyRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResizePtyRequest {
    pub fn new() -> ResizePtyRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width
    }

    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = v;
    }

    // uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height
    }

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ResizePtyRequest| { &m.id },
            |m: &mut ResizePtyRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &ResizePtyRequest| { &m.exec_id },
            |m: &mut ResizePtyRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &ResizePtyRequest| { &m.width },
            |m: &mut ResizePtyRequest| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ResizePtyRequest| { &m.height },
            |m: &mut ResizePtyRequest| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResizePtyRequest>(
            "ResizePtyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResizePtyRequest {
    const NAME: &'static str = "ResizePtyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.width = is.read_uint32()?;
                },
                32 => {
                    self.height = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.width != 0 {
            os.write_uint32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_uint32(4, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResizePtyRequest {
        ResizePtyRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.width = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResizePtyRequest {
        static instance: ResizePtyRequest = ResizePtyRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            width: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResizePtyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResizePtyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResizePtyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResizePtyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StateRequest)
pub struct StateRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StateRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateRequest {
    fn default() -> &'a StateRequest {
        <StateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StateRequest {
    pub fn new() -> StateRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StateRequest| { &m.id },
            |m: &mut StateRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &StateRequest| { &m.exec_id },
            |m: &mut StateRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateRequest>(
            "StateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateRequest {
    const NAME: &'static str = "StateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateRequest {
        StateRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateRequest {
        static instance: StateRequest = StateRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StateResponse)
pub struct StateResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.bundle)
    pub bundle: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.pid)
    pub pid: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.status)
    pub status: ::protobuf::EnumOrUnknown<super::task::Status>,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.stdin)
    pub stdin: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.stdout)
    pub stdout: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.stderr)
    pub stderr: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.terminal)
    pub terminal: bool,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.exit_status)
    pub exit_status: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.exited_at)
    pub exited_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:containerd.task.v2.StateResponse.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateResponse {
    fn default() -> &'a StateResponse {
        <StateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StateResponse {
    pub fn new() -> StateResponse {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string bundle = 2;

    pub fn bundle(&self) -> &str {
        &self.bundle
    }

    pub fn clear_bundle(&mut self) {
        self.bundle.clear();
    }

    // Param is passed by value, moved
    pub fn set_bundle(&mut self, v: ::std::string::String) {
        self.bundle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bundle(&mut self) -> &mut ::std::string::String {
        &mut self.bundle
    }

    // Take field
    pub fn take_bundle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bundle, ::std::string::String::new())
    }

    // uint32 pid = 3;

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    // .containerd.v1.types.Status status = 4;

    pub fn status(&self) -> super::task::Status {
        self.status.enum_value_or_default()
    }

    pub fn clear_status(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(super::task::Status::UNKNOWN);
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::task::Status) {
        self.status = ::protobuf::EnumOrUnknown::new(v);
    }

    // string stdin = 5;

    pub fn stdin(&self) -> &str {
        &self.stdin
    }

    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::string::String) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::string::String {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdin, ::std::string::String::new())
    }

    // string stdout = 6;

    pub fn stdout(&self) -> &str {
        &self.stdout
    }

    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::string::String) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::string::String {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stdout, ::std::string::String::new())
    }

    // string stderr = 7;

    pub fn stderr(&self) -> &str {
        &self.stderr
    }

    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::string::String) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::string::String {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stderr, ::std::string::String::new())
    }

    // bool terminal = 8;

    pub fn terminal(&self) -> bool {
        self.terminal
    }

    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }

    // uint32 exit_status = 9;

    pub fn exit_status(&self) -> u32 {
        self.exit_status
    }

    pub fn clear_exit_status(&mut self) {
        self.exit_status = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_status(&mut self, v: u32) {
        self.exit_status = v;
    }

    // .google.protobuf.Timestamp exited_at = 10;

    pub fn exited_at(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exited_at(&mut self) {
        self.exited_at.clear();
    }

    pub fn has_exited_at(&self) -> bool {
        self.exited_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exited_at(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
        self.exited_at = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exited_at(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.mut_or_insert_default()
    }

    // Take field
    pub fn take_exited_at(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.take().unwrap_or_else(|| ::protobuf::well_known_types::timestamp::Timestamp::new())
    }

    // string exec_id = 11;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StateResponse| { &m.id },
            |m: &mut StateResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bundle",
            |m: &StateResponse| { &m.bundle },
            |m: &mut StateResponse| { &mut m.bundle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pid",
            |m: &StateResponse| { &m.pid },
            |m: &mut StateResponse| { &mut m.pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &StateResponse| { &m.status },
            |m: &mut StateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdin",
            |m: &StateResponse| { &m.stdin },
            |m: &mut StateResponse| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdout",
            |m: &StateResponse| { &m.stdout },
            |m: &mut StateResponse| { &mut m.stdout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stderr",
            |m: &StateResponse| { &m.stderr },
            |m: &mut StateResponse| { &mut m.stderr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "terminal",
            |m: &StateResponse| { &m.terminal },
            |m: &mut StateResponse| { &mut m.terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exit_status",
            |m: &StateResponse| { &m.exit_status },
            |m: &mut StateResponse| { &mut m.exit_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "exited_at",
            |m: &StateResponse| { &m.exited_at },
            |m: &mut StateResponse| { &mut m.exited_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &StateResponse| { &m.exec_id },
            |m: &mut StateResponse| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateResponse>(
            "StateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateResponse {
    const NAME: &'static str = "StateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.bundle = is.read_string()?;
                },
                24 => {
                    self.pid = is.read_uint32()?;
                },
                32 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.stdin = is.read_string()?;
                },
                50 => {
                    self.stdout = is.read_string()?;
                },
                58 => {
                    self.stderr = is.read_string()?;
                },
                64 => {
                    self.terminal = is.read_bool()?;
                },
                72 => {
                    self.exit_status = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exited_at)?;
                },
                90 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.bundle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bundle);
        }
        if self.pid != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.pid);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::task::Status::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.status.value());
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.stdin);
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.stderr);
        }
        if self.terminal != false {
            my_size += 1 + 1;
        }
        if self.exit_status != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.exit_status);
        }
        if let Some(v) = self.exited_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.bundle.is_empty() {
            os.write_string(2, &self.bundle)?;
        }
        if self.pid != 0 {
            os.write_uint32(3, self.pid)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(super::task::Status::UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.stdin.is_empty() {
            os.write_string(5, &self.stdin)?;
        }
        if !self.stdout.is_empty() {
            os.write_string(6, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_string(7, &self.stderr)?;
        }
        if self.terminal != false {
            os.write_bool(8, self.terminal)?;
        }
        if self.exit_status != 0 {
            os.write_uint32(9, self.exit_status)?;
        }
        if let Some(v) = self.exited_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(11, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateResponse {
        StateResponse::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.bundle.clear();
        self.pid = 0;
        self.status = ::protobuf::EnumOrUnknown::new(super::task::Status::UNKNOWN);
        self.stdin.clear();
        self.stdout.clear();
        self.stderr.clear();
        self.terminal = false;
        self.exit_status = 0;
        self.exited_at.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateResponse {
        static instance: StateResponse = StateResponse {
            id: ::std::string::String::new(),
            bundle: ::std::string::String::new(),
            pid: 0,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            stdin: ::std::string::String::new(),
            stdout: ::std::string::String::new(),
            stderr: ::std::string::String::new(),
            terminal: false,
            exit_status: 0,
            exited_at: ::protobuf::MessageField::none(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.KillRequest)
pub struct KillRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.KillRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.KillRequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.KillRequest.signal)
    pub signal: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.KillRequest.all)
    pub all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.KillRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KillRequest {
    fn default() -> &'a KillRequest {
        <KillRequest as ::protobuf::Message>::default_instance()
    }
}

impl KillRequest {
    pub fn new() -> KillRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // uint32 signal = 3;

    pub fn signal(&self) -> u32 {
        self.signal
    }

    pub fn clear_signal(&mut self) {
        self.signal = 0;
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: u32) {
        self.signal = v;
    }

    // bool all = 4;

    pub fn all(&self) -> bool {
        self.all
    }

    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &KillRequest| { &m.id },
            |m: &mut KillRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &KillRequest| { &m.exec_id },
            |m: &mut KillRequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signal",
            |m: &KillRequest| { &m.signal },
            |m: &mut KillRequest| { &mut m.signal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "all",
            |m: &KillRequest| { &m.all },
            |m: &mut KillRequest| { &mut m.all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KillRequest>(
            "KillRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KillRequest {
    const NAME: &'static str = "KillRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.signal = is.read_uint32()?;
                },
                32 => {
                    self.all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.signal != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.signal);
        }
        if self.all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.signal != 0 {
            os.write_uint32(3, self.signal)?;
        }
        if self.all != false {
            os.write_bool(4, self.all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KillRequest {
        KillRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.signal = 0;
        self.all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KillRequest {
        static instance: KillRequest = KillRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            signal: 0,
            all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KillRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KillRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KillRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KillRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.CloseIORequest)
pub struct CloseIORequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.CloseIORequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CloseIORequest.exec_id)
    pub exec_id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CloseIORequest.stdin)
    pub stdin: bool,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.CloseIORequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CloseIORequest {
    fn default() -> &'a CloseIORequest {
        <CloseIORequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseIORequest {
    pub fn new() -> CloseIORequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    // bool stdin = 3;

    pub fn stdin(&self) -> bool {
        self.stdin
    }

    pub fn clear_stdin(&mut self) {
        self.stdin = false;
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CloseIORequest| { &m.id },
            |m: &mut CloseIORequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &CloseIORequest| { &m.exec_id },
            |m: &mut CloseIORequest| { &mut m.exec_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stdin",
            |m: &CloseIORequest| { &m.stdin },
            |m: &mut CloseIORequest| { &mut m.stdin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseIORequest>(
            "CloseIORequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CloseIORequest {
    const NAME: &'static str = "CloseIORequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                24 => {
                    self.stdin = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        if self.stdin != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        if self.stdin != false {
            os.write_bool(3, self.stdin)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CloseIORequest {
        CloseIORequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.stdin = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CloseIORequest {
        static instance: CloseIORequest = CloseIORequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            stdin: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CloseIORequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CloseIORequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CloseIORequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseIORequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.PidsRequest)
pub struct PidsRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.PidsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.PidsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PidsRequest {
    fn default() -> &'a PidsRequest {
        <PidsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PidsRequest {
    pub fn new() -> PidsRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PidsRequest| { &m.id },
            |m: &mut PidsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PidsRequest>(
            "PidsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PidsRequest {
    const NAME: &'static str = "PidsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PidsRequest {
        PidsRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PidsRequest {
        static instance: PidsRequest = PidsRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PidsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PidsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PidsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.PidsResponse)
pub struct PidsResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.PidsResponse.processes)
    pub processes: ::std::vec::Vec<super::task::ProcessInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.PidsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PidsResponse {
    fn default() -> &'a PidsResponse {
        <PidsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PidsResponse {
    pub fn new() -> PidsResponse {
        ::std::default::Default::default()
    }

    // repeated .containerd.v1.types.ProcessInfo processes = 1;

    pub fn processes(&self) -> &[super::task::ProcessInfo] {
        &self.processes
    }

    pub fn clear_processes(&mut self) {
        self.processes.clear();
    }

    // Param is passed by value, moved
    pub fn set_processes(&mut self, v: ::std::vec::Vec<super::task::ProcessInfo>) {
        self.processes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_processes(&mut self) -> &mut ::std::vec::Vec<super::task::ProcessInfo> {
        &mut self.processes
    }

    // Take field
    pub fn take_processes(&mut self) -> ::std::vec::Vec<super::task::ProcessInfo> {
        ::std::mem::replace(&mut self.processes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes",
            |m: &PidsResponse| { &m.processes },
            |m: &mut PidsResponse| { &mut m.processes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PidsResponse>(
            "PidsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PidsResponse {
    const NAME: &'static str = "PidsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.processes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.processes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.processes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PidsResponse {
        PidsResponse::new()
    }

    fn clear(&mut self) {
        self.processes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PidsResponse {
        static instance: PidsResponse = PidsResponse {
            processes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PidsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PidsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PidsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.CheckpointTaskRequest)
pub struct CheckpointTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.CheckpointTaskRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CheckpointTaskRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.CheckpointTaskRequest.options)
    pub options: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.CheckpointTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CheckpointTaskRequest {
    fn default() -> &'a CheckpointTaskRequest {
        <CheckpointTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckpointTaskRequest {
    pub fn new() -> CheckpointTaskRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string path = 2;

    pub fn path(&self) -> &str {
        &self.path
    }

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .google.protobuf.Any options = 3;

    pub fn options(&self) -> &::protobuf::well_known_types::any::Any {
        self.options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance())
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.options = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        self.options.mut_or_insert_default()
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::well_known_types::any::Any {
        self.options.take().unwrap_or_else(|| ::protobuf::well_known_types::any::Any::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CheckpointTaskRequest| { &m.id },
            |m: &mut CheckpointTaskRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &CheckpointTaskRequest| { &m.path },
            |m: &mut CheckpointTaskRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "options",
            |m: &CheckpointTaskRequest| { &m.options },
            |m: &mut CheckpointTaskRequest| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CheckpointTaskRequest>(
            "CheckpointTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CheckpointTaskRequest {
    const NAME: &'static str = "CheckpointTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CheckpointTaskRequest {
        CheckpointTaskRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.path.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CheckpointTaskRequest {
        static instance: CheckpointTaskRequest = CheckpointTaskRequest {
            id: ::std::string::String::new(),
            path: ::std::string::String::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CheckpointTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CheckpointTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CheckpointTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckpointTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.UpdateTaskRequest)
pub struct UpdateTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.UpdateTaskRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.UpdateTaskRequest.resources)
    pub resources: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:containerd.task.v2.UpdateTaskRequest.annotations)
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.UpdateTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateTaskRequest {
    fn default() -> &'a UpdateTaskRequest {
        <UpdateTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTaskRequest {
    pub fn new() -> UpdateTaskRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Any resources = 2;

    pub fn resources(&self) -> &::protobuf::well_known_types::any::Any {
        self.resources.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::well_known_types::any::Any {
        self.resources.take().unwrap_or_else(|| ::protobuf::well_known_types::any::Any::new())
    }

    // repeated .containerd.task.v2.UpdateTaskRequest.AnnotationsEntry annotations = 3;

    pub fn annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }

    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UpdateTaskRequest| { &m.id },
            |m: &mut UpdateTaskRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "resources",
            |m: &UpdateTaskRequest| { &m.resources },
            |m: &mut UpdateTaskRequest| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "annotations",
            |m: &UpdateTaskRequest| { &m.annotations },
            |m: &mut UpdateTaskRequest| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateTaskRequest>(
            "UpdateTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateTaskRequest {
    const NAME: &'static str = "UpdateTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.annotations.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateTaskRequest {
        UpdateTaskRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.resources.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateTaskRequest {
        static instance: ::protobuf::rt::Lazy<UpdateTaskRequest> = ::protobuf::rt::Lazy::new();
        instance.get(UpdateTaskRequest::new)
    }
}

impl ::protobuf::MessageFull for UpdateTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StartRequest)
pub struct StartRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StartRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.StartRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StartRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartRequest {
    fn default() -> &'a StartRequest {
        <StartRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartRequest {
    pub fn new() -> StartRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StartRequest| { &m.id },
            |m: &mut StartRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &StartRequest| { &m.exec_id },
            |m: &mut StartRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartRequest>(
            "StartRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartRequest {
    const NAME: &'static str = "StartRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartRequest {
        StartRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartRequest {
        static instance: StartRequest = StartRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StartResponse)
pub struct StartResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StartResponse.pid)
    pub pid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StartResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartResponse {
    fn default() -> &'a StartResponse {
        <StartResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartResponse {
    pub fn new() -> StartResponse {
        ::std::default::Default::default()
    }

    // uint32 pid = 1;

    pub fn pid(&self) -> u32 {
        self.pid
    }

    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pid",
            |m: &StartResponse| { &m.pid },
            |m: &mut StartResponse| { &mut m.pid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartResponse>(
            "StartResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartResponse {
    const NAME: &'static str = "StartResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.pid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pid != 0 {
            os.write_uint32(1, self.pid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartResponse {
        StartResponse::new()
    }

    fn clear(&mut self) {
        self.pid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartResponse {
        static instance: StartResponse = StartResponse {
            pid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.WaitRequest)
pub struct WaitRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.WaitRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.WaitRequest.exec_id)
    pub exec_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.WaitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WaitRequest {
    fn default() -> &'a WaitRequest {
        <WaitRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitRequest {
    pub fn new() -> WaitRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string exec_id = 2;

    pub fn exec_id(&self) -> &str {
        &self.exec_id
    }

    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::string::String) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::string::String {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exec_id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WaitRequest| { &m.id },
            |m: &mut WaitRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exec_id",
            |m: &WaitRequest| { &m.exec_id },
            |m: &mut WaitRequest| { &mut m.exec_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WaitRequest>(
            "WaitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WaitRequest {
    const NAME: &'static str = "WaitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.exec_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.exec_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_string(2, &self.exec_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WaitRequest {
        WaitRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.exec_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WaitRequest {
        static instance: WaitRequest = WaitRequest {
            id: ::std::string::String::new(),
            exec_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WaitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WaitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WaitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.WaitResponse)
pub struct WaitResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.WaitResponse.exit_status)
    pub exit_status: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.WaitResponse.exited_at)
    pub exited_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.WaitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WaitResponse {
    fn default() -> &'a WaitResponse {
        <WaitResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitResponse {
    pub fn new() -> WaitResponse {
        ::std::default::Default::default()
    }

    // uint32 exit_status = 1;

    pub fn exit_status(&self) -> u32 {
        self.exit_status
    }

    pub fn clear_exit_status(&mut self) {
        self.exit_status = 0;
    }

    // Param is passed by value, moved
    pub fn set_exit_status(&mut self, v: u32) {
        self.exit_status = v;
    }

    // .google.protobuf.Timestamp exited_at = 2;

    pub fn exited_at(&self) -> &::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::timestamp::Timestamp as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exited_at(&mut self) {
        self.exited_at.clear();
    }

    pub fn has_exited_at(&self) -> bool {
        self.exited_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exited_at(&mut self, v: ::protobuf::well_known_types::timestamp::Timestamp) {
        self.exited_at = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exited_at(&mut self) -> &mut ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.mut_or_insert_default()
    }

    // Take field
    pub fn take_exited_at(&mut self) -> ::protobuf::well_known_types::timestamp::Timestamp {
        self.exited_at.take().unwrap_or_else(|| ::protobuf::well_known_types::timestamp::Timestamp::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exit_status",
            |m: &WaitResponse| { &m.exit_status },
            |m: &mut WaitResponse| { &mut m.exit_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "exited_at",
            |m: &WaitResponse| { &m.exited_at },
            |m: &mut WaitResponse| { &mut m.exited_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WaitResponse>(
            "WaitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WaitResponse {
    const NAME: &'static str = "WaitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.exit_status = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exited_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.exit_status != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.exit_status);
        }
        if let Some(v) = self.exited_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.exit_status != 0 {
            os.write_uint32(1, self.exit_status)?;
        }
        if let Some(v) = self.exited_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WaitResponse {
        WaitResponse::new()
    }

    fn clear(&mut self) {
        self.exit_status = 0;
        self.exited_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WaitResponse {
        static instance: WaitResponse = WaitResponse {
            exit_status: 0,
            exited_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WaitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WaitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WaitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StatsRequest)
pub struct StatsRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StatsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsRequest {
    fn default() -> &'a StatsRequest {
        <StatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsRequest {
    pub fn new() -> StatsRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &StatsRequest| { &m.id },
            |m: &mut StatsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsRequest>(
            "StatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsRequest {
    const NAME: &'static str = "StatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsRequest {
        StatsRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsRequest {
        static instance: StatsRequest = StatsRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.StatsResponse)
pub struct StatsResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.StatsResponse.stats)
    pub stats: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.StatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsResponse {
    fn default() -> &'a StatsResponse {
        <StatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsResponse {
    pub fn new() -> StatsResponse {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any stats = 1;

    pub fn stats(&self) -> &::protobuf::well_known_types::any::Any {
        self.stats.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::any::Any as ::protobuf::Message>::default_instance())
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::well_known_types::any::Any) {
        self.stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::well_known_types::any::Any {
        self.stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::well_known_types::any::Any {
        self.stats.take().unwrap_or_else(|| ::protobuf::well_known_types::any::Any::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "stats",
            |m: &StatsResponse| { &m.stats },
            |m: &mut StatsResponse| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsResponse>(
            "StatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsResponse {
    const NAME: &'static str = "StatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsResponse {
        StatsResponse::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsResponse {
        static instance: StatsResponse = StatsResponse {
            stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ConnectRequest)
pub struct ConnectRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ConnectRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ConnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectRequest {
    fn default() -> &'a ConnectRequest {
        <ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectRequest {
    pub fn new() -> ConnectRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ConnectRequest| { &m.id },
            |m: &mut ConnectRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectRequest>(
            "ConnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectRequest {
    const NAME: &'static str = "ConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectRequest {
        ConnectRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectRequest {
        static instance: ConnectRequest = ConnectRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ConnectResponse)
pub struct ConnectResponse {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ConnectResponse.shim_pid)
    pub shim_pid: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.ConnectResponse.task_pid)
    pub task_pid: u32,
    // @@protoc_insertion_point(field:containerd.task.v2.ConnectResponse.version)
    pub version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ConnectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectResponse {
    fn default() -> &'a ConnectResponse {
        <ConnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectResponse {
    pub fn new() -> ConnectResponse {
        ::std::default::Default::default()
    }

    // uint32 shim_pid = 1;

    pub fn shim_pid(&self) -> u32 {
        self.shim_pid
    }

    pub fn clear_shim_pid(&mut self) {
        self.shim_pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_shim_pid(&mut self, v: u32) {
        self.shim_pid = v;
    }

    // uint32 task_pid = 2;

    pub fn task_pid(&self) -> u32 {
        self.task_pid
    }

    pub fn clear_task_pid(&mut self) {
        self.task_pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_task_pid(&mut self, v: u32) {
        self.task_pid = v;
    }

    // string version = 3;

    pub fn version(&self) -> &str {
        &self.version
    }

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shim_pid",
            |m: &ConnectResponse| { &m.shim_pid },
            |m: &mut ConnectResponse| { &mut m.shim_pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_pid",
            |m: &ConnectResponse| { &m.task_pid },
            |m: &mut ConnectResponse| { &mut m.task_pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &ConnectResponse| { &m.version },
            |m: &mut ConnectResponse| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectResponse>(
            "ConnectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectResponse {
    const NAME: &'static str = "ConnectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shim_pid = is.read_uint32()?;
                },
                16 => {
                    self.task_pid = is.read_uint32()?;
                },
                26 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shim_pid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shim_pid);
        }
        if self.task_pid != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.task_pid);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shim_pid != 0 {
            os.write_uint32(1, self.shim_pid)?;
        }
        if self.task_pid != 0 {
            os.write_uint32(2, self.task_pid)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectResponse {
        ConnectResponse::new()
    }

    fn clear(&mut self) {
        self.shim_pid = 0;
        self.task_pid = 0;
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectResponse {
        static instance: ConnectResponse = ConnectResponse {
            shim_pid: 0,
            task_pid: 0,
            version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ShutdownRequest)
pub struct ShutdownRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ShutdownRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:containerd.task.v2.ShutdownRequest.now)
    pub now: bool,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ShutdownRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShutdownRequest {
    fn default() -> &'a ShutdownRequest {
        <ShutdownRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShutdownRequest {
    pub fn new() -> ShutdownRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool now = 2;

    pub fn now(&self) -> bool {
        self.now
    }

    pub fn clear_now(&mut self) {
        self.now = false;
    }

    // Param is passed by value, moved
    pub fn set_now(&mut self, v: bool) {
        self.now = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ShutdownRequest| { &m.id },
            |m: &mut ShutdownRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "now",
            |m: &ShutdownRequest| { &m.now },
            |m: &mut ShutdownRequest| { &mut m.now },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShutdownRequest>(
            "ShutdownRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShutdownRequest {
    const NAME: &'static str = "ShutdownRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.now = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.now != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.now != false {
            os.write_bool(2, self.now)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShutdownRequest {
        ShutdownRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.now = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShutdownRequest {
        static instance: ShutdownRequest = ShutdownRequest {
            id: ::std::string::String::new(),
            now: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShutdownRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShutdownRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShutdownRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShutdownRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.PauseRequest)
pub struct PauseRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.PauseRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.PauseRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PauseRequest {
    fn default() -> &'a PauseRequest {
        <PauseRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseRequest {
    pub fn new() -> PauseRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PauseRequest| { &m.id },
            |m: &mut PauseRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PauseRequest>(
            "PauseRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PauseRequest {
    const NAME: &'static str = "PauseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PauseRequest {
        PauseRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PauseRequest {
        static instance: PauseRequest = PauseRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PauseRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PauseRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PauseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:containerd.task.v2.ResumeRequest)
pub struct ResumeRequest {
    // message fields
    // @@protoc_insertion_point(field:containerd.task.v2.ResumeRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:containerd.task.v2.ResumeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResumeRequest {
    fn default() -> &'a ResumeRequest {
        <ResumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResumeRequest {
    pub fn new() -> ResumeRequest {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ResumeRequest| { &m.id },
            |m: &mut ResumeRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResumeRequest>(
            "ResumeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResumeRequest {
    const NAME: &'static str = "ResumeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResumeRequest {
        ResumeRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResumeRequest {
        static instance: ResumeRequest = ResumeRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResumeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResumeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResumeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResumeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n;github.com/containerd/containerd/runtime/v2/task/shim.proto\x12\x12co\
    ntainerd.task.v2\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf\
    /empty.proto\x1a\x14gogoproto/gogo.proto\x1a\x1fgoogle/protobuf/timestam\
    p.proto\x1a6github.com/containerd/containerd/api/types/mount.proto\x1a:g\
    ithub.com/containerd/containerd/api/types/task/task.protoX\x02\"\xcb\x02\
    \n\x11CreateTaskRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x16\n\x06bundle\x18\x02\x20\x01(\tR\x06bundle\x12/\n\x06rootfs\x18\x03\
    \x20\x03(\x0b2\x17.containerd.types.MountR\x06rootfs\x12\x1a\n\x08termin\
    al\x18\x04\x20\x01(\x08R\x08terminal\x12\x14\n\x05stdin\x18\x05\x20\x01(\
    \tR\x05stdin\x12\x16\n\x06stdout\x18\x06\x20\x01(\tR\x06stdout\x12\x16\n\
    \x06stderr\x18\x07\x20\x01(\tR\x06stderr\x12\x1e\n\ncheckpoint\x18\x08\
    \x20\x01(\tR\ncheckpoint\x12+\n\x11parent_checkpoint\x18\t\x20\x01(\tR\
    \x10parentCheckpoint\x12.\n\x07options\x18\n\x20\x01(\x0b2\x14.google.pr\
    otobuf.AnyR\x07options\"&\n\x12CreateTaskResponse\x12\x10\n\x03pid\x18\
    \x01\x20\x01(\rR\x03pid\"8\n\rDeleteRequest\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\"\x86\
    \x01\n\x0eDeleteResponse\x12\x10\n\x03pid\x18\x01\x20\x01(\rR\x03pid\x12\
    \x1f\n\x0bexit_status\x18\x02\x20\x01(\rR\nexitStatus\x12A\n\texited_at\
    \x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08exitedAtB\x08\
    \x90\xdf\x1f\x01\xc8\xde\x1f\0\"\xc9\x01\n\x12ExecProcessRequest\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\
    \tR\x06execId\x12\x1a\n\x08terminal\x18\x03\x20\x01(\x08R\x08terminal\
    \x12\x14\n\x05stdin\x18\x04\x20\x01(\tR\x05stdin\x12\x16\n\x06stdout\x18\
    \x05\x20\x01(\tR\x06stdout\x12\x16\n\x06stderr\x18\x06\x20\x01(\tR\x06st\
    derr\x12(\n\x04spec\x18\x07\x20\x01(\x0b2\x14.google.protobuf.AnyR\x04sp\
    ec\"\x15\n\x13ExecProcessResponse\"i\n\x10ResizePtyRequest\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\
    \x06execId\x12\x14\n\x05width\x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06\
    height\x18\x04\x20\x01(\rR\x06height\"7\n\x0cStateRequest\x12\x0e\n\x02i\
    d\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06\
    execId\"\xdd\x02\n\rStateResponse\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x16\n\x06bundle\x18\x02\x20\x01(\tR\x06bundle\x12\x10\n\x03pi\
    d\x18\x03\x20\x01(\rR\x03pid\x123\n\x06status\x18\x04\x20\x01(\x0e2\x1b.\
    containerd.v1.types.StatusR\x06status\x12\x14\n\x05stdin\x18\x05\x20\x01\
    (\tR\x05stdin\x12\x16\n\x06stdout\x18\x06\x20\x01(\tR\x06stdout\x12\x16\
    \n\x06stderr\x18\x07\x20\x01(\tR\x06stderr\x12\x1a\n\x08terminal\x18\x08\
    \x20\x01(\x08R\x08terminal\x12\x1f\n\x0bexit_status\x18\t\x20\x01(\rR\ne\
    xitStatus\x12A\n\texited_at\x18\n\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\x08exitedAtB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\0\x12\x17\n\x07exec_\
    id\x18\x0b\x20\x01(\tR\x06execId\"`\n\x0bKillRequest\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execI\
    d\x12\x16\n\x06signal\x18\x03\x20\x01(\rR\x06signal\x12\x10\n\x03all\x18\
    \x04\x20\x01(\x08R\x03all\"O\n\x0eCloseIORequest\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\
    \x12\x14\n\x05stdin\x18\x03\x20\x01(\x08R\x05stdin\"\x1d\n\x0bPidsReques\
    t\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"N\n\x0cPidsResponse\x12>\n\
    \tprocesses\x18\x01\x20\x03(\x0b2\x20.containerd.v1.types.ProcessInfoR\t\
    processes\"k\n\x15CheckpointTaskRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12.\n\x07option\
    s\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyR\x07options\"\xf1\x01\n\
    \x11UpdateTaskRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x122\n\t\
    resources\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\tresources\x12X\
    \n\x0bannotations\x18\x03\x20\x03(\x0b26.containerd.task.v2.UpdateTaskRe\
    quest.AnnotationsEntryR\x0bannotations\x1a>\n\x10AnnotationsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"7\n\x0cStartRequest\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x17\n\x07exec_id\x18\x02\x20\x01(\tR\x06execId\"!\
    \n\rStartResponse\x12\x10\n\x03pid\x18\x01\x20\x01(\rR\x03pid\"6\n\x0bWa\
    itRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07exec_id\
    \x18\x02\x20\x01(\tR\x06execId\"r\n\x0cWaitResponse\x12\x1f\n\x0bexit_st\
    atus\x18\x01\x20\x01(\rR\nexitStatus\x12A\n\texited_at\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x08exitedAtB\x08\x90\xdf\x1f\x01\
    \xc8\xde\x1f\0\"\x1e\n\x0cStatsRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\";\n\rStatsResponse\x12*\n\x05stats\x18\x01\x20\x01(\x0b2\x14.\
    google.protobuf.AnyR\x05stats\"\x20\n\x0eConnectRequest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\"a\n\x0fConnectResponse\x12\x19\n\x08shim_pid\
    \x18\x01\x20\x01(\rR\x07shimPid\x12\x19\n\x08task_pid\x18\x02\x20\x01(\r\
    R\x07taskPid\x12\x18\n\x07version\x18\x03\x20\x01(\tR\x07version\"3\n\
    \x0fShutdownRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x10\n\
    \x03now\x18\x02\x20\x01(\x08R\x03now\"\x1e\n\x0cPauseRequest\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\"\x1f\n\rResumeRequest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id2\x8a\n\n\x04Task\x12L\n\x05State\x12\x20.cont\
    ainerd.task.v2.StateRequest\x1a!.containerd.task.v2.StateResponse\x12W\n\
    \x06Create\x12%.containerd.task.v2.CreateTaskRequest\x1a&.containerd.tas\
    k.v2.CreateTaskResponse\x12L\n\x05Start\x12\x20.containerd.task.v2.Start\
    Request\x1a!.containerd.task.v2.StartResponse\x12O\n\x06Delete\x12!.cont\
    ainerd.task.v2.DeleteRequest\x1a\".containerd.task.v2.DeleteResponse\x12\
    I\n\x04Pids\x12\x1f.containerd.task.v2.PidsRequest\x1a\x20.containerd.ta\
    sk.v2.PidsResponse\x12A\n\x05Pause\x12\x20.containerd.task.v2.PauseReque\
    st\x1a\x16.google.protobuf.Empty\x12C\n\x06Resume\x12!.containerd.task.v\
    2.ResumeRequest\x1a\x16.google.protobuf.Empty\x12O\n\nCheckpoint\x12).co\
    ntainerd.task.v2.CheckpointTaskRequest\x1a\x16.google.protobuf.Empty\x12\
    ?\n\x04Kill\x12\x1f.containerd.task.v2.KillRequest\x1a\x16.google.protob\
    uf.Empty\x12F\n\x04Exec\x12&.containerd.task.v2.ExecProcessRequest\x1a\
    \x16.google.protobuf.Empty\x12I\n\tResizePty\x12$.containerd.task.v2.Res\
    izePtyRequest\x1a\x16.google.protobuf.Empty\x12E\n\x07CloseIO\x12\".cont\
    ainerd.task.v2.CloseIORequest\x1a\x16.google.protobuf.Empty\x12G\n\x06Up\
    date\x12%.containerd.task.v2.UpdateTaskRequest\x1a\x16.google.protobuf.E\
    mpty\x12I\n\x04Wait\x12\x1f.containerd.task.v2.WaitRequest\x1a\x20.conta\
    inerd.task.v2.WaitResponse\x12L\n\x05Stats\x12\x20.containerd.task.v2.St\
    atsRequest\x1a!.containerd.task.v2.StatsResponse\x12R\n\x07Connect\x12\"\
    .containerd.task.v2.ConnectRequest\x1a#.containerd.task.v2.ConnectRespon\
    se\x12G\n\x08Shutdown\x12#.containerd.task.v2.ShutdownRequest\x1a\x16.go\
    ogle.protobuf.EmptyB7Z5github.com/containerd/containerd/runtime/v2/task;\
    taskb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(6);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(super::gogo::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::mount::file_descriptor().clone());
            deps.push(super::task::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(CreateTaskRequest::generated_message_descriptor_data());
            messages.push(CreateTaskResponse::generated_message_descriptor_data());
            messages.push(DeleteRequest::generated_message_descriptor_data());
            messages.push(DeleteResponse::generated_message_descriptor_data());
            messages.push(ExecProcessRequest::generated_message_descriptor_data());
            messages.push(ExecProcessResponse::generated_message_descriptor_data());
            messages.push(ResizePtyRequest::generated_message_descriptor_data());
            messages.push(StateRequest::generated_message_descriptor_data());
            messages.push(StateResponse::generated_message_descriptor_data());
            messages.push(KillRequest::generated_message_descriptor_data());
            messages.push(CloseIORequest::generated_message_descriptor_data());
            messages.push(PidsRequest::generated_message_descriptor_data());
            messages.push(PidsResponse::generated_message_descriptor_data());
            messages.push(CheckpointTaskRequest::generated_message_descriptor_data());
            messages.push(UpdateTaskRequest::generated_message_descriptor_data());
            messages.push(StartRequest::generated_message_descriptor_data());
            messages.push(StartResponse::generated_message_descriptor_data());
            messages.push(WaitRequest::generated_message_descriptor_data());
            messages.push(WaitResponse::generated_message_descriptor_data());
            messages.push(StatsRequest::generated_message_descriptor_data());
            messages.push(StatsResponse::generated_message_descriptor_data());
            messages.push(ConnectRequest::generated_message_descriptor_data());
            messages.push(ConnectResponse::generated_message_descriptor_data());
            messages.push(ShutdownRequest::generated_message_descriptor_data());
            messages.push(PauseRequest::generated_message_descriptor_data());
            messages.push(ResumeRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
