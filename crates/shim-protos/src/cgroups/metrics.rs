// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `github.com/containerd/cgroups/stats/v1/metrics.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.Metrics)
pub struct Metrics {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.hugetlb)
    pub hugetlb: ::std::vec::Vec<HugetlbStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.pids)
    pub pids: ::protobuf::MessageField<PidsStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.cpu)
    pub cpu: ::protobuf::MessageField<CPUStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.memory)
    pub memory: ::protobuf::MessageField<MemoryStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.blkio)
    pub blkio: ::protobuf::MessageField<BlkIOStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.rdma)
    pub rdma: ::protobuf::MessageField<RdmaStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.network)
    pub network: ::std::vec::Vec<NetworkStat>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.cgroup_stats)
    pub cgroup_stats: ::protobuf::MessageField<CgroupStats>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Metrics.memory_oom_control)
    pub memory_oom_control: ::protobuf::MessageField<MemoryOomControl>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.Metrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metrics {
    fn default() -> &'a Metrics {
        <Metrics as ::protobuf::Message>::default_instance()
    }
}

impl Metrics {
    pub fn new() -> Metrics {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.HugetlbStat hugetlb = 1;

    pub fn hugetlb(&self) -> &[HugetlbStat] {
        &self.hugetlb
    }

    pub fn clear_hugetlb(&mut self) {
        self.hugetlb.clear();
    }

    // Param is passed by value, moved
    pub fn set_hugetlb(&mut self, v: ::std::vec::Vec<HugetlbStat>) {
        self.hugetlb = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hugetlb(&mut self) -> &mut ::std::vec::Vec<HugetlbStat> {
        &mut self.hugetlb
    }

    // Take field
    pub fn take_hugetlb(&mut self) -> ::std::vec::Vec<HugetlbStat> {
        ::std::mem::replace(&mut self.hugetlb, ::std::vec::Vec::new())
    }

    // .io.containerd.cgroups.v1.PidsStat pids = 2;

    pub fn pids(&self) -> &PidsStat {
        self.pids.as_ref().unwrap_or_else(|| <PidsStat as ::protobuf::Message>::default_instance())
    }

    pub fn clear_pids(&mut self) {
        self.pids.clear();
    }

    pub fn has_pids(&self) -> bool {
        self.pids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pids(&mut self, v: PidsStat) {
        self.pids = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pids(&mut self) -> &mut PidsStat {
        self.pids.mut_or_insert_default()
    }

    // Take field
    pub fn take_pids(&mut self) -> PidsStat {
        self.pids.take().unwrap_or_else(|| PidsStat::new())
    }

    // .io.containerd.cgroups.v1.CPUStat cpu = 3;

    pub fn cpu(&self) -> &CPUStat {
        self.cpu.as_ref().unwrap_or_else(|| <CPUStat as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    pub fn has_cpu(&self) -> bool {
        self.cpu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: CPUStat) {
        self.cpu = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu(&mut self) -> &mut CPUStat {
        self.cpu.mut_or_insert_default()
    }

    // Take field
    pub fn take_cpu(&mut self) -> CPUStat {
        self.cpu.take().unwrap_or_else(|| CPUStat::new())
    }

    // .io.containerd.cgroups.v1.MemoryStat memory = 4;

    pub fn memory(&self) -> &MemoryStat {
        self.memory.as_ref().unwrap_or_else(|| <MemoryStat as ::protobuf::Message>::default_instance())
    }

    pub fn clear_memory(&mut self) {
        self.memory.clear();
    }

    pub fn has_memory(&self) -> bool {
        self.memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: MemoryStat) {
        self.memory = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory(&mut self) -> &mut MemoryStat {
        self.memory.mut_or_insert_default()
    }

    // Take field
    pub fn take_memory(&mut self) -> MemoryStat {
        self.memory.take().unwrap_or_else(|| MemoryStat::new())
    }

    // .io.containerd.cgroups.v1.BlkIOStat blkio = 5;

    pub fn blkio(&self) -> &BlkIOStat {
        self.blkio.as_ref().unwrap_or_else(|| <BlkIOStat as ::protobuf::Message>::default_instance())
    }

    pub fn clear_blkio(&mut self) {
        self.blkio.clear();
    }

    pub fn has_blkio(&self) -> bool {
        self.blkio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkio(&mut self, v: BlkIOStat) {
        self.blkio = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkio(&mut self) -> &mut BlkIOStat {
        self.blkio.mut_or_insert_default()
    }

    // Take field
    pub fn take_blkio(&mut self) -> BlkIOStat {
        self.blkio.take().unwrap_or_else(|| BlkIOStat::new())
    }

    // .io.containerd.cgroups.v1.RdmaStat rdma = 6;

    pub fn rdma(&self) -> &RdmaStat {
        self.rdma.as_ref().unwrap_or_else(|| <RdmaStat as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rdma(&mut self) {
        self.rdma.clear();
    }

    pub fn has_rdma(&self) -> bool {
        self.rdma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rdma(&mut self, v: RdmaStat) {
        self.rdma = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rdma(&mut self) -> &mut RdmaStat {
        self.rdma.mut_or_insert_default()
    }

    // Take field
    pub fn take_rdma(&mut self) -> RdmaStat {
        self.rdma.take().unwrap_or_else(|| RdmaStat::new())
    }

    // repeated .io.containerd.cgroups.v1.NetworkStat network = 7;

    pub fn network(&self) -> &[NetworkStat] {
        &self.network
    }

    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::vec::Vec<NetworkStat>) {
        self.network = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network(&mut self) -> &mut ::std::vec::Vec<NetworkStat> {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::vec::Vec<NetworkStat> {
        ::std::mem::replace(&mut self.network, ::std::vec::Vec::new())
    }

    // .io.containerd.cgroups.v1.CgroupStats cgroup_stats = 8;

    pub fn cgroup_stats(&self) -> &CgroupStats {
        self.cgroup_stats.as_ref().unwrap_or_else(|| <CgroupStats as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cgroup_stats(&mut self) {
        self.cgroup_stats.clear();
    }

    pub fn has_cgroup_stats(&self) -> bool {
        self.cgroup_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_stats(&mut self, v: CgroupStats) {
        self.cgroup_stats = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_stats(&mut self) -> &mut CgroupStats {
        self.cgroup_stats.mut_or_insert_default()
    }

    // Take field
    pub fn take_cgroup_stats(&mut self) -> CgroupStats {
        self.cgroup_stats.take().unwrap_or_else(|| CgroupStats::new())
    }

    // .io.containerd.cgroups.v1.MemoryOomControl memory_oom_control = 9;

    pub fn memory_oom_control(&self) -> &MemoryOomControl {
        self.memory_oom_control.as_ref().unwrap_or_else(|| <MemoryOomControl as ::protobuf::Message>::default_instance())
    }

    pub fn clear_memory_oom_control(&mut self) {
        self.memory_oom_control.clear();
    }

    pub fn has_memory_oom_control(&self) -> bool {
        self.memory_oom_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_oom_control(&mut self, v: MemoryOomControl) {
        self.memory_oom_control = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_oom_control(&mut self) -> &mut MemoryOomControl {
        self.memory_oom_control.mut_or_insert_default()
    }

    // Take field
    pub fn take_memory_oom_control(&mut self) -> MemoryOomControl {
        self.memory_oom_control.take().unwrap_or_else(|| MemoryOomControl::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hugetlb",
            |m: &Metrics| { &m.hugetlb },
            |m: &mut Metrics| { &mut m.hugetlb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PidsStat>(
            "pids",
            |m: &Metrics| { &m.pids },
            |m: &mut Metrics| { &mut m.pids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CPUStat>(
            "cpu",
            |m: &Metrics| { &m.cpu },
            |m: &mut Metrics| { &mut m.cpu },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryStat>(
            "memory",
            |m: &Metrics| { &m.memory },
            |m: &mut Metrics| { &mut m.memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlkIOStat>(
            "blkio",
            |m: &Metrics| { &m.blkio },
            |m: &mut Metrics| { &mut m.blkio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RdmaStat>(
            "rdma",
            |m: &Metrics| { &m.rdma },
            |m: &mut Metrics| { &mut m.rdma },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "network",
            |m: &Metrics| { &m.network },
            |m: &mut Metrics| { &mut m.network },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CgroupStats>(
            "cgroup_stats",
            |m: &Metrics| { &m.cgroup_stats },
            |m: &mut Metrics| { &mut m.cgroup_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryOomControl>(
            "memory_oom_control",
            |m: &Metrics| { &m.memory_oom_control },
            |m: &mut Metrics| { &mut m.memory_oom_control },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metrics>(
            "Metrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metrics {
    const NAME: &'static str = "Metrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hugetlb.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pids)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cpu)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.memory)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blkio)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rdma)?;
                },
                58 => {
                    self.network.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cgroup_stats)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.memory_oom_control)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hugetlb {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pids.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cpu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blkio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rdma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.network {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cgroup_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.memory_oom_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hugetlb {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pids.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.cpu.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.memory.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.blkio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.rdma.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.network {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.cgroup_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.memory_oom_control.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metrics {
        Metrics::new()
    }

    fn clear(&mut self) {
        self.hugetlb.clear();
        self.pids.clear();
        self.cpu.clear();
        self.memory.clear();
        self.blkio.clear();
        self.rdma.clear();
        self.network.clear();
        self.cgroup_stats.clear();
        self.memory_oom_control.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metrics {
        static instance: Metrics = Metrics {
            hugetlb: ::std::vec::Vec::new(),
            pids: ::protobuf::MessageField::none(),
            cpu: ::protobuf::MessageField::none(),
            memory: ::protobuf::MessageField::none(),
            blkio: ::protobuf::MessageField::none(),
            rdma: ::protobuf::MessageField::none(),
            network: ::std::vec::Vec::new(),
            cgroup_stats: ::protobuf::MessageField::none(),
            memory_oom_control: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.HugetlbStat)
pub struct HugetlbStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.HugetlbStat.usage)
    pub usage: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.HugetlbStat.max)
    pub max: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.HugetlbStat.failcnt)
    pub failcnt: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.HugetlbStat.pagesize)
    pub pagesize: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.HugetlbStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HugetlbStat {
    fn default() -> &'a HugetlbStat {
        <HugetlbStat as ::protobuf::Message>::default_instance()
    }
}

impl HugetlbStat {
    pub fn new() -> HugetlbStat {
        ::std::default::Default::default()
    }

    // uint64 usage = 1;

    pub fn usage(&self) -> u64 {
        self.usage
    }

    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max = 2;

    pub fn max(&self) -> u64 {
        self.max
    }

    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u64) {
        self.max = v;
    }

    // uint64 failcnt = 3;

    pub fn failcnt(&self) -> u64 {
        self.failcnt
    }

    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    // string pagesize = 4;

    pub fn pagesize(&self) -> &str {
        &self.pagesize
    }

    pub fn clear_pagesize(&mut self) {
        self.pagesize.clear();
    }

    // Param is passed by value, moved
    pub fn set_pagesize(&mut self, v: ::std::string::String) {
        self.pagesize = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagesize(&mut self) -> &mut ::std::string::String {
        &mut self.pagesize
    }

    // Take field
    pub fn take_pagesize(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pagesize, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &HugetlbStat| { &m.usage },
            |m: &mut HugetlbStat| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max",
            |m: &HugetlbStat| { &m.max },
            |m: &mut HugetlbStat| { &mut m.max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failcnt",
            |m: &HugetlbStat| { &m.failcnt },
            |m: &mut HugetlbStat| { &mut m.failcnt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pagesize",
            |m: &HugetlbStat| { &m.pagesize },
            |m: &mut HugetlbStat| { &mut m.pagesize },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HugetlbStat>(
            "HugetlbStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HugetlbStat {
    const NAME: &'static str = "HugetlbStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.usage = is.read_uint64()?;
                },
                16 => {
                    self.max = is.read_uint64()?;
                },
                24 => {
                    self.failcnt = is.read_uint64()?;
                },
                34 => {
                    self.pagesize = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.usage != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.usage);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.max);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.failcnt);
        }
        if !self.pagesize.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pagesize);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.usage != 0 {
            os.write_uint64(1, self.usage)?;
        }
        if self.max != 0 {
            os.write_uint64(2, self.max)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(3, self.failcnt)?;
        }
        if !self.pagesize.is_empty() {
            os.write_string(4, &self.pagesize)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HugetlbStat {
        HugetlbStat::new()
    }

    fn clear(&mut self) {
        self.usage = 0;
        self.max = 0;
        self.failcnt = 0;
        self.pagesize.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HugetlbStat {
        static instance: HugetlbStat = HugetlbStat {
            usage: 0,
            max: 0,
            failcnt: 0,
            pagesize: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HugetlbStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HugetlbStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HugetlbStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HugetlbStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.PidsStat)
pub struct PidsStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.PidsStat.current)
    pub current: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.PidsStat.limit)
    pub limit: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.PidsStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PidsStat {
    fn default() -> &'a PidsStat {
        <PidsStat as ::protobuf::Message>::default_instance()
    }
}

impl PidsStat {
    pub fn new() -> PidsStat {
        ::std::default::Default::default()
    }

    // uint64 current = 1;

    pub fn current(&self) -> u64 {
        self.current
    }

    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 limit = 2;

    pub fn limit(&self) -> u64 {
        self.limit
    }

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current",
            |m: &PidsStat| { &m.current },
            |m: &mut PidsStat| { &mut m.current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PidsStat| { &m.limit },
            |m: &mut PidsStat| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PidsStat>(
            "PidsStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PidsStat {
    const NAME: &'static str = "PidsStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current = is.read_uint64()?;
                },
                16 => {
                    self.limit = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.current);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PidsStat {
        PidsStat::new()
    }

    fn clear(&mut self) {
        self.current = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PidsStat {
        static instance: PidsStat = PidsStat {
            current: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PidsStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PidsStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PidsStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PidsStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.CPUStat)
pub struct CPUStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUStat.usage)
    pub usage: ::protobuf::MessageField<CPUUsage>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUStat.throttling)
    pub throttling: ::protobuf::MessageField<Throttle>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.CPUStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPUStat {
    fn default() -> &'a CPUStat {
        <CPUStat as ::protobuf::Message>::default_instance()
    }
}

impl CPUStat {
    pub fn new() -> CPUStat {
        ::std::default::Default::default()
    }

    // .io.containerd.cgroups.v1.CPUUsage usage = 1;

    pub fn usage(&self) -> &CPUUsage {
        self.usage.as_ref().unwrap_or_else(|| <CPUUsage as ::protobuf::Message>::default_instance())
    }

    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: CPUUsage) {
        self.usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut CPUUsage {
        self.usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_usage(&mut self) -> CPUUsage {
        self.usage.take().unwrap_or_else(|| CPUUsage::new())
    }

    // .io.containerd.cgroups.v1.Throttle throttling = 2;

    pub fn throttling(&self) -> &Throttle {
        self.throttling.as_ref().unwrap_or_else(|| <Throttle as ::protobuf::Message>::default_instance())
    }

    pub fn clear_throttling(&mut self) {
        self.throttling.clear();
    }

    pub fn has_throttling(&self) -> bool {
        self.throttling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling(&mut self, v: Throttle) {
        self.throttling = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_throttling(&mut self) -> &mut Throttle {
        self.throttling.mut_or_insert_default()
    }

    // Take field
    pub fn take_throttling(&mut self) -> Throttle {
        self.throttling.take().unwrap_or_else(|| Throttle::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CPUUsage>(
            "usage",
            |m: &CPUStat| { &m.usage },
            |m: &mut CPUStat| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Throttle>(
            "throttling",
            |m: &CPUStat| { &m.throttling },
            |m: &mut CPUStat| { &mut m.throttling },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPUStat>(
            "CPUStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPUStat {
    const NAME: &'static str = "CPUStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.throttling)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.throttling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.throttling.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPUStat {
        CPUStat::new()
    }

    fn clear(&mut self) {
        self.usage.clear();
        self.throttling.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPUStat {
        static instance: CPUStat = CPUStat {
            usage: ::protobuf::MessageField::none(),
            throttling: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPUStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPUStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPUStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPUStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.CPUUsage)
pub struct CPUUsage {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUUsage.total)
    pub total: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUUsage.kernel)
    pub kernel: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUUsage.user)
    pub user: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CPUUsage.per_cpu)
    pub per_cpu: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.CPUUsage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPUUsage {
    fn default() -> &'a CPUUsage {
        <CPUUsage as ::protobuf::Message>::default_instance()
    }
}

impl CPUUsage {
    pub fn new() -> CPUUsage {
        ::std::default::Default::default()
    }

    // uint64 total = 1;

    pub fn total(&self) -> u64 {
        self.total
    }

    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u64) {
        self.total = v;
    }

    // uint64 kernel = 2;

    pub fn kernel(&self) -> u64 {
        self.kernel
    }

    pub fn clear_kernel(&mut self) {
        self.kernel = 0;
    }

    // Param is passed by value, moved
    pub fn set_kernel(&mut self, v: u64) {
        self.kernel = v;
    }

    // uint64 user = 3;

    pub fn user(&self) -> u64 {
        self.user
    }

    pub fn clear_user(&mut self) {
        self.user = 0;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: u64) {
        self.user = v;
    }

    // repeated uint64 per_cpu = 4;

    pub fn per_cpu(&self) -> &[u64] {
        &self.per_cpu
    }

    pub fn clear_per_cpu(&mut self) {
        self.per_cpu.clear();
    }

    // Param is passed by value, moved
    pub fn set_per_cpu(&mut self, v: ::std::vec::Vec<u64>) {
        self.per_cpu = v;
    }

    // Mutable pointer to the field.
    pub fn mut_per_cpu(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.per_cpu
    }

    // Take field
    pub fn take_per_cpu(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.per_cpu, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &CPUUsage| { &m.total },
            |m: &mut CPUUsage| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kernel",
            |m: &CPUUsage| { &m.kernel },
            |m: &mut CPUUsage| { &mut m.kernel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user",
            |m: &CPUUsage| { &m.user },
            |m: &mut CPUUsage| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "per_cpu",
            |m: &CPUUsage| { &m.per_cpu },
            |m: &mut CPUUsage| { &mut m.per_cpu },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPUUsage>(
            "CPUUsage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPUUsage {
    const NAME: &'static str = "CPUUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.total = is.read_uint64()?;
                },
                16 => {
                    self.kernel = is.read_uint64()?;
                },
                24 => {
                    self.user = is.read_uint64()?;
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.per_cpu)?;
                },
                32 => {
                    self.per_cpu.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.total);
        }
        if self.kernel != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.kernel);
        }
        if self.user != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.user);
        }
        for value in &self.per_cpu {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.total != 0 {
            os.write_uint64(1, self.total)?;
        }
        if self.kernel != 0 {
            os.write_uint64(2, self.kernel)?;
        }
        if self.user != 0 {
            os.write_uint64(3, self.user)?;
        }
        for v in &self.per_cpu {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPUUsage {
        CPUUsage::new()
    }

    fn clear(&mut self) {
        self.total = 0;
        self.kernel = 0;
        self.user = 0;
        self.per_cpu.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPUUsage {
        static instance: CPUUsage = CPUUsage {
            total: 0,
            kernel: 0,
            user: 0,
            per_cpu: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPUUsage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPUUsage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPUUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPUUsage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.Throttle)
pub struct Throttle {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Throttle.periods)
    pub periods: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Throttle.throttled_periods)
    pub throttled_periods: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.Throttle.throttled_time)
    pub throttled_time: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.Throttle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Throttle {
    fn default() -> &'a Throttle {
        <Throttle as ::protobuf::Message>::default_instance()
    }
}

impl Throttle {
    pub fn new() -> Throttle {
        ::std::default::Default::default()
    }

    // uint64 periods = 1;

    pub fn periods(&self) -> u64 {
        self.periods
    }

    pub fn clear_periods(&mut self) {
        self.periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_periods(&mut self, v: u64) {
        self.periods = v;
    }

    // uint64 throttled_periods = 2;

    pub fn throttled_periods(&self) -> u64 {
        self.throttled_periods
    }

    pub fn clear_throttled_periods(&mut self) {
        self.throttled_periods = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_periods(&mut self, v: u64) {
        self.throttled_periods = v;
    }

    // uint64 throttled_time = 3;

    pub fn throttled_time(&self) -> u64 {
        self.throttled_time
    }

    pub fn clear_throttled_time(&mut self) {
        self.throttled_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttled_time(&mut self, v: u64) {
        self.throttled_time = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "periods",
            |m: &Throttle| { &m.periods },
            |m: &mut Throttle| { &mut m.periods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "throttled_periods",
            |m: &Throttle| { &m.throttled_periods },
            |m: &mut Throttle| { &mut m.throttled_periods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "throttled_time",
            |m: &Throttle| { &m.throttled_time },
            |m: &mut Throttle| { &mut m.throttled_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Throttle>(
            "Throttle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Throttle {
    const NAME: &'static str = "Throttle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.periods = is.read_uint64()?;
                },
                16 => {
                    self.throttled_periods = is.read_uint64()?;
                },
                24 => {
                    self.throttled_time = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.periods != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.periods);
        }
        if self.throttled_periods != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.throttled_periods);
        }
        if self.throttled_time != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.throttled_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.periods != 0 {
            os.write_uint64(1, self.periods)?;
        }
        if self.throttled_periods != 0 {
            os.write_uint64(2, self.throttled_periods)?;
        }
        if self.throttled_time != 0 {
            os.write_uint64(3, self.throttled_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Throttle {
        Throttle::new()
    }

    fn clear(&mut self) {
        self.periods = 0;
        self.throttled_periods = 0;
        self.throttled_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Throttle {
        static instance: Throttle = Throttle {
            periods: 0,
            throttled_periods: 0,
            throttled_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Throttle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Throttle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Throttle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Throttle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.MemoryStat)
pub struct MemoryStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.cache)
    pub cache: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.rss)
    pub rss: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.rss_huge)
    pub rss_huge: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.mapped_file)
    pub mapped_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.dirty)
    pub dirty: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.writeback)
    pub writeback: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.pg_pg_in)
    pub pg_pg_in: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.pg_pg_out)
    pub pg_pg_out: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.pg_fault)
    pub pg_fault: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.pg_maj_fault)
    pub pg_maj_fault: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.inactive_anon)
    pub inactive_anon: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.active_anon)
    pub active_anon: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.inactive_file)
    pub inactive_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.active_file)
    pub active_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.unevictable)
    pub unevictable: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.hierarchical_memory_limit)
    pub hierarchical_memory_limit: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.hierarchical_swap_limit)
    pub hierarchical_swap_limit: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_cache)
    pub total_cache: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_rss)
    pub total_rss: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_rss_huge)
    pub total_rss_huge: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_mapped_file)
    pub total_mapped_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_dirty)
    pub total_dirty: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_writeback)
    pub total_writeback: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_pg_pg_in)
    pub total_pg_pg_in: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_pg_pg_out)
    pub total_pg_pg_out: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_pg_fault)
    pub total_pg_fault: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_pg_maj_fault)
    pub total_pg_maj_fault: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_inactive_anon)
    pub total_inactive_anon: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_active_anon)
    pub total_active_anon: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_inactive_file)
    pub total_inactive_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_active_file)
    pub total_active_file: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.total_unevictable)
    pub total_unevictable: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.usage)
    pub usage: ::protobuf::MessageField<MemoryEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.swap)
    pub swap: ::protobuf::MessageField<MemoryEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.kernel)
    pub kernel: ::protobuf::MessageField<MemoryEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryStat.kernel_tcp)
    pub kernel_tcp: ::protobuf::MessageField<MemoryEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.MemoryStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemoryStat {
    fn default() -> &'a MemoryStat {
        <MemoryStat as ::protobuf::Message>::default_instance()
    }
}

impl MemoryStat {
    pub fn new() -> MemoryStat {
        ::std::default::Default::default()
    }

    // uint64 cache = 1;

    pub fn cache(&self) -> u64 {
        self.cache
    }

    pub fn clear_cache(&mut self) {
        self.cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: u64) {
        self.cache = v;
    }

    // uint64 rss = 2;

    pub fn rss(&self) -> u64 {
        self.rss
    }

    pub fn clear_rss(&mut self) {
        self.rss = 0;
    }

    // Param is passed by value, moved
    pub fn set_rss(&mut self, v: u64) {
        self.rss = v;
    }

    // uint64 rss_huge = 3;

    pub fn rss_huge(&self) -> u64 {
        self.rss_huge
    }

    pub fn clear_rss_huge(&mut self) {
        self.rss_huge = 0;
    }

    // Param is passed by value, moved
    pub fn set_rss_huge(&mut self, v: u64) {
        self.rss_huge = v;
    }

    // uint64 mapped_file = 4;

    pub fn mapped_file(&self) -> u64 {
        self.mapped_file
    }

    pub fn clear_mapped_file(&mut self) {
        self.mapped_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_mapped_file(&mut self, v: u64) {
        self.mapped_file = v;
    }

    // uint64 dirty = 5;

    pub fn dirty(&self) -> u64 {
        self.dirty
    }

    pub fn clear_dirty(&mut self) {
        self.dirty = 0;
    }

    // Param is passed by value, moved
    pub fn set_dirty(&mut self, v: u64) {
        self.dirty = v;
    }

    // uint64 writeback = 6;

    pub fn writeback(&self) -> u64 {
        self.writeback
    }

    pub fn clear_writeback(&mut self) {
        self.writeback = 0;
    }

    // Param is passed by value, moved
    pub fn set_writeback(&mut self, v: u64) {
        self.writeback = v;
    }

    // uint64 pg_pg_in = 7;

    pub fn pg_pg_in(&self) -> u64 {
        self.pg_pg_in
    }

    pub fn clear_pg_pg_in(&mut self) {
        self.pg_pg_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_pg_in(&mut self, v: u64) {
        self.pg_pg_in = v;
    }

    // uint64 pg_pg_out = 8;

    pub fn pg_pg_out(&self) -> u64 {
        self.pg_pg_out
    }

    pub fn clear_pg_pg_out(&mut self) {
        self.pg_pg_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_pg_out(&mut self, v: u64) {
        self.pg_pg_out = v;
    }

    // uint64 pg_fault = 9;

    pub fn pg_fault(&self) -> u64 {
        self.pg_fault
    }

    pub fn clear_pg_fault(&mut self) {
        self.pg_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_fault(&mut self, v: u64) {
        self.pg_fault = v;
    }

    // uint64 pg_maj_fault = 10;

    pub fn pg_maj_fault(&self) -> u64 {
        self.pg_maj_fault
    }

    pub fn clear_pg_maj_fault(&mut self) {
        self.pg_maj_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_pg_maj_fault(&mut self, v: u64) {
        self.pg_maj_fault = v;
    }

    // uint64 inactive_anon = 11;

    pub fn inactive_anon(&self) -> u64 {
        self.inactive_anon
    }

    pub fn clear_inactive_anon(&mut self) {
        self.inactive_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_inactive_anon(&mut self, v: u64) {
        self.inactive_anon = v;
    }

    // uint64 active_anon = 12;

    pub fn active_anon(&self) -> u64 {
        self.active_anon
    }

    pub fn clear_active_anon(&mut self) {
        self.active_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_anon(&mut self, v: u64) {
        self.active_anon = v;
    }

    // uint64 inactive_file = 13;

    pub fn inactive_file(&self) -> u64 {
        self.inactive_file
    }

    pub fn clear_inactive_file(&mut self) {
        self.inactive_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_inactive_file(&mut self, v: u64) {
        self.inactive_file = v;
    }

    // uint64 active_file = 14;

    pub fn active_file(&self) -> u64 {
        self.active_file
    }

    pub fn clear_active_file(&mut self) {
        self.active_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_file(&mut self, v: u64) {
        self.active_file = v;
    }

    // uint64 unevictable = 15;

    pub fn unevictable(&self) -> u64 {
        self.unevictable
    }

    pub fn clear_unevictable(&mut self) {
        self.unevictable = 0;
    }

    // Param is passed by value, moved
    pub fn set_unevictable(&mut self, v: u64) {
        self.unevictable = v;
    }

    // uint64 hierarchical_memory_limit = 16;

    pub fn hierarchical_memory_limit(&self) -> u64 {
        self.hierarchical_memory_limit
    }

    pub fn clear_hierarchical_memory_limit(&mut self) {
        self.hierarchical_memory_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_memory_limit(&mut self, v: u64) {
        self.hierarchical_memory_limit = v;
    }

    // uint64 hierarchical_swap_limit = 17;

    pub fn hierarchical_swap_limit(&self) -> u64 {
        self.hierarchical_swap_limit
    }

    pub fn clear_hierarchical_swap_limit(&mut self) {
        self.hierarchical_swap_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_hierarchical_swap_limit(&mut self, v: u64) {
        self.hierarchical_swap_limit = v;
    }

    // uint64 total_cache = 18;

    pub fn total_cache(&self) -> u64 {
        self.total_cache
    }

    pub fn clear_total_cache(&mut self) {
        self.total_cache = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_cache(&mut self, v: u64) {
        self.total_cache = v;
    }

    // uint64 total_rss = 19;

    pub fn total_rss(&self) -> u64 {
        self.total_rss
    }

    pub fn clear_total_rss(&mut self) {
        self.total_rss = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rss(&mut self, v: u64) {
        self.total_rss = v;
    }

    // uint64 total_rss_huge = 20;

    pub fn total_rss_huge(&self) -> u64 {
        self.total_rss_huge
    }

    pub fn clear_total_rss_huge(&mut self) {
        self.total_rss_huge = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rss_huge(&mut self, v: u64) {
        self.total_rss_huge = v;
    }

    // uint64 total_mapped_file = 21;

    pub fn total_mapped_file(&self) -> u64 {
        self.total_mapped_file
    }

    pub fn clear_total_mapped_file(&mut self) {
        self.total_mapped_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_mapped_file(&mut self, v: u64) {
        self.total_mapped_file = v;
    }

    // uint64 total_dirty = 22;

    pub fn total_dirty(&self) -> u64 {
        self.total_dirty
    }

    pub fn clear_total_dirty(&mut self) {
        self.total_dirty = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_dirty(&mut self, v: u64) {
        self.total_dirty = v;
    }

    // uint64 total_writeback = 23;

    pub fn total_writeback(&self) -> u64 {
        self.total_writeback
    }

    pub fn clear_total_writeback(&mut self) {
        self.total_writeback = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_writeback(&mut self, v: u64) {
        self.total_writeback = v;
    }

    // uint64 total_pg_pg_in = 24;

    pub fn total_pg_pg_in(&self) -> u64 {
        self.total_pg_pg_in
    }

    pub fn clear_total_pg_pg_in(&mut self) {
        self.total_pg_pg_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_pg_in(&mut self, v: u64) {
        self.total_pg_pg_in = v;
    }

    // uint64 total_pg_pg_out = 25;

    pub fn total_pg_pg_out(&self) -> u64 {
        self.total_pg_pg_out
    }

    pub fn clear_total_pg_pg_out(&mut self) {
        self.total_pg_pg_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_pg_out(&mut self, v: u64) {
        self.total_pg_pg_out = v;
    }

    // uint64 total_pg_fault = 26;

    pub fn total_pg_fault(&self) -> u64 {
        self.total_pg_fault
    }

    pub fn clear_total_pg_fault(&mut self) {
        self.total_pg_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_fault(&mut self, v: u64) {
        self.total_pg_fault = v;
    }

    // uint64 total_pg_maj_fault = 27;

    pub fn total_pg_maj_fault(&self) -> u64 {
        self.total_pg_maj_fault
    }

    pub fn clear_total_pg_maj_fault(&mut self) {
        self.total_pg_maj_fault = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_pg_maj_fault(&mut self, v: u64) {
        self.total_pg_maj_fault = v;
    }

    // uint64 total_inactive_anon = 28;

    pub fn total_inactive_anon(&self) -> u64 {
        self.total_inactive_anon
    }

    pub fn clear_total_inactive_anon(&mut self) {
        self.total_inactive_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_inactive_anon(&mut self, v: u64) {
        self.total_inactive_anon = v;
    }

    // uint64 total_active_anon = 29;

    pub fn total_active_anon(&self) -> u64 {
        self.total_active_anon
    }

    pub fn clear_total_active_anon(&mut self) {
        self.total_active_anon = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_active_anon(&mut self, v: u64) {
        self.total_active_anon = v;
    }

    // uint64 total_inactive_file = 30;

    pub fn total_inactive_file(&self) -> u64 {
        self.total_inactive_file
    }

    pub fn clear_total_inactive_file(&mut self) {
        self.total_inactive_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_inactive_file(&mut self, v: u64) {
        self.total_inactive_file = v;
    }

    // uint64 total_active_file = 31;

    pub fn total_active_file(&self) -> u64 {
        self.total_active_file
    }

    pub fn clear_total_active_file(&mut self) {
        self.total_active_file = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_active_file(&mut self, v: u64) {
        self.total_active_file = v;
    }

    // uint64 total_unevictable = 32;

    pub fn total_unevictable(&self) -> u64 {
        self.total_unevictable
    }

    pub fn clear_total_unevictable(&mut self) {
        self.total_unevictable = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_unevictable(&mut self, v: u64) {
        self.total_unevictable = v;
    }

    // .io.containerd.cgroups.v1.MemoryEntry usage = 33;

    pub fn usage(&self) -> &MemoryEntry {
        self.usage.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }

    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: MemoryEntry) {
        self.usage = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut MemoryEntry {
        self.usage.mut_or_insert_default()
    }

    // Take field
    pub fn take_usage(&mut self) -> MemoryEntry {
        self.usage.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry swap = 34;

    pub fn swap(&self) -> &MemoryEntry {
        self.swap.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }

    pub fn clear_swap(&mut self) {
        self.swap.clear();
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: MemoryEntry) {
        self.swap = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swap(&mut self) -> &mut MemoryEntry {
        self.swap.mut_or_insert_default()
    }

    // Take field
    pub fn take_swap(&mut self) -> MemoryEntry {
        self.swap.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry kernel = 35;

    pub fn kernel(&self) -> &MemoryEntry {
        self.kernel.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }

    pub fn clear_kernel(&mut self) {
        self.kernel.clear();
    }

    pub fn has_kernel(&self) -> bool {
        self.kernel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel(&mut self, v: MemoryEntry) {
        self.kernel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel(&mut self) -> &mut MemoryEntry {
        self.kernel.mut_or_insert_default()
    }

    // Take field
    pub fn take_kernel(&mut self) -> MemoryEntry {
        self.kernel.take().unwrap_or_else(|| MemoryEntry::new())
    }

    // .io.containerd.cgroups.v1.MemoryEntry kernel_tcp = 36;

    pub fn kernel_tcp(&self) -> &MemoryEntry {
        self.kernel_tcp.as_ref().unwrap_or_else(|| <MemoryEntry as ::protobuf::Message>::default_instance())
    }

    pub fn clear_kernel_tcp(&mut self) {
        self.kernel_tcp.clear();
    }

    pub fn has_kernel_tcp(&self) -> bool {
        self.kernel_tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_tcp(&mut self, v: MemoryEntry) {
        self.kernel_tcp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_tcp(&mut self) -> &mut MemoryEntry {
        self.kernel_tcp.mut_or_insert_default()
    }

    // Take field
    pub fn take_kernel_tcp(&mut self) -> MemoryEntry {
        self.kernel_tcp.take().unwrap_or_else(|| MemoryEntry::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(36);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cache",
            |m: &MemoryStat| { &m.cache },
            |m: &mut MemoryStat| { &mut m.cache },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rss",
            |m: &MemoryStat| { &m.rss },
            |m: &mut MemoryStat| { &mut m.rss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rss_huge",
            |m: &MemoryStat| { &m.rss_huge },
            |m: &mut MemoryStat| { &mut m.rss_huge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mapped_file",
            |m: &MemoryStat| { &m.mapped_file },
            |m: &mut MemoryStat| { &mut m.mapped_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dirty",
            |m: &MemoryStat| { &m.dirty },
            |m: &mut MemoryStat| { &mut m.dirty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "writeback",
            |m: &MemoryStat| { &m.writeback },
            |m: &mut MemoryStat| { &mut m.writeback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_pg_in",
            |m: &MemoryStat| { &m.pg_pg_in },
            |m: &mut MemoryStat| { &mut m.pg_pg_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_pg_out",
            |m: &MemoryStat| { &m.pg_pg_out },
            |m: &mut MemoryStat| { &mut m.pg_pg_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_fault",
            |m: &MemoryStat| { &m.pg_fault },
            |m: &mut MemoryStat| { &mut m.pg_fault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pg_maj_fault",
            |m: &MemoryStat| { &m.pg_maj_fault },
            |m: &mut MemoryStat| { &mut m.pg_maj_fault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inactive_anon",
            |m: &MemoryStat| { &m.inactive_anon },
            |m: &mut MemoryStat| { &mut m.inactive_anon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_anon",
            |m: &MemoryStat| { &m.active_anon },
            |m: &mut MemoryStat| { &mut m.active_anon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inactive_file",
            |m: &MemoryStat| { &m.inactive_file },
            |m: &mut MemoryStat| { &mut m.inactive_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_file",
            |m: &MemoryStat| { &m.active_file },
            |m: &mut MemoryStat| { &mut m.active_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unevictable",
            |m: &MemoryStat| { &m.unevictable },
            |m: &mut MemoryStat| { &mut m.unevictable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hierarchical_memory_limit",
            |m: &MemoryStat| { &m.hierarchical_memory_limit },
            |m: &mut MemoryStat| { &mut m.hierarchical_memory_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hierarchical_swap_limit",
            |m: &MemoryStat| { &m.hierarchical_swap_limit },
            |m: &mut MemoryStat| { &mut m.hierarchical_swap_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_cache",
            |m: &MemoryStat| { &m.total_cache },
            |m: &mut MemoryStat| { &mut m.total_cache },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_rss",
            |m: &MemoryStat| { &m.total_rss },
            |m: &mut MemoryStat| { &mut m.total_rss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_rss_huge",
            |m: &MemoryStat| { &m.total_rss_huge },
            |m: &mut MemoryStat| { &mut m.total_rss_huge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_mapped_file",
            |m: &MemoryStat| { &m.total_mapped_file },
            |m: &mut MemoryStat| { &mut m.total_mapped_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_dirty",
            |m: &MemoryStat| { &m.total_dirty },
            |m: &mut MemoryStat| { &mut m.total_dirty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_writeback",
            |m: &MemoryStat| { &m.total_writeback },
            |m: &mut MemoryStat| { &mut m.total_writeback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pg_pg_in",
            |m: &MemoryStat| { &m.total_pg_pg_in },
            |m: &mut MemoryStat| { &mut m.total_pg_pg_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pg_pg_out",
            |m: &MemoryStat| { &m.total_pg_pg_out },
            |m: &mut MemoryStat| { &mut m.total_pg_pg_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pg_fault",
            |m: &MemoryStat| { &m.total_pg_fault },
            |m: &mut MemoryStat| { &mut m.total_pg_fault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pg_maj_fault",
            |m: &MemoryStat| { &m.total_pg_maj_fault },
            |m: &mut MemoryStat| { &mut m.total_pg_maj_fault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_inactive_anon",
            |m: &MemoryStat| { &m.total_inactive_anon },
            |m: &mut MemoryStat| { &mut m.total_inactive_anon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_active_anon",
            |m: &MemoryStat| { &m.total_active_anon },
            |m: &mut MemoryStat| { &mut m.total_active_anon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_inactive_file",
            |m: &MemoryStat| { &m.total_inactive_file },
            |m: &mut MemoryStat| { &mut m.total_inactive_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_active_file",
            |m: &MemoryStat| { &m.total_active_file },
            |m: &mut MemoryStat| { &mut m.total_active_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_unevictable",
            |m: &MemoryStat| { &m.total_unevictable },
            |m: &mut MemoryStat| { &mut m.total_unevictable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryEntry>(
            "usage",
            |m: &MemoryStat| { &m.usage },
            |m: &mut MemoryStat| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryEntry>(
            "swap",
            |m: &MemoryStat| { &m.swap },
            |m: &mut MemoryStat| { &mut m.swap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryEntry>(
            "kernel",
            |m: &MemoryStat| { &m.kernel },
            |m: &mut MemoryStat| { &mut m.kernel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MemoryEntry>(
            "kernel_tcp",
            |m: &MemoryStat| { &m.kernel_tcp },
            |m: &mut MemoryStat| { &mut m.kernel_tcp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryStat>(
            "MemoryStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemoryStat {
    const NAME: &'static str = "MemoryStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cache = is.read_uint64()?;
                },
                16 => {
                    self.rss = is.read_uint64()?;
                },
                24 => {
                    self.rss_huge = is.read_uint64()?;
                },
                32 => {
                    self.mapped_file = is.read_uint64()?;
                },
                40 => {
                    self.dirty = is.read_uint64()?;
                },
                48 => {
                    self.writeback = is.read_uint64()?;
                },
                56 => {
                    self.pg_pg_in = is.read_uint64()?;
                },
                64 => {
                    self.pg_pg_out = is.read_uint64()?;
                },
                72 => {
                    self.pg_fault = is.read_uint64()?;
                },
                80 => {
                    self.pg_maj_fault = is.read_uint64()?;
                },
                88 => {
                    self.inactive_anon = is.read_uint64()?;
                },
                96 => {
                    self.active_anon = is.read_uint64()?;
                },
                104 => {
                    self.inactive_file = is.read_uint64()?;
                },
                112 => {
                    self.active_file = is.read_uint64()?;
                },
                120 => {
                    self.unevictable = is.read_uint64()?;
                },
                128 => {
                    self.hierarchical_memory_limit = is.read_uint64()?;
                },
                136 => {
                    self.hierarchical_swap_limit = is.read_uint64()?;
                },
                144 => {
                    self.total_cache = is.read_uint64()?;
                },
                152 => {
                    self.total_rss = is.read_uint64()?;
                },
                160 => {
                    self.total_rss_huge = is.read_uint64()?;
                },
                168 => {
                    self.total_mapped_file = is.read_uint64()?;
                },
                176 => {
                    self.total_dirty = is.read_uint64()?;
                },
                184 => {
                    self.total_writeback = is.read_uint64()?;
                },
                192 => {
                    self.total_pg_pg_in = is.read_uint64()?;
                },
                200 => {
                    self.total_pg_pg_out = is.read_uint64()?;
                },
                208 => {
                    self.total_pg_fault = is.read_uint64()?;
                },
                216 => {
                    self.total_pg_maj_fault = is.read_uint64()?;
                },
                224 => {
                    self.total_inactive_anon = is.read_uint64()?;
                },
                232 => {
                    self.total_active_anon = is.read_uint64()?;
                },
                240 => {
                    self.total_inactive_file = is.read_uint64()?;
                },
                248 => {
                    self.total_active_file = is.read_uint64()?;
                },
                256 => {
                    self.total_unevictable = is.read_uint64()?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                274 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.swap)?;
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kernel)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kernel_tcp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cache != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.cache);
        }
        if self.rss != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.rss);
        }
        if self.rss_huge != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.rss_huge);
        }
        if self.mapped_file != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.mapped_file);
        }
        if self.dirty != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.dirty);
        }
        if self.writeback != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.writeback);
        }
        if self.pg_pg_in != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.pg_pg_in);
        }
        if self.pg_pg_out != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.pg_pg_out);
        }
        if self.pg_fault != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.pg_fault);
        }
        if self.pg_maj_fault != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.pg_maj_fault);
        }
        if self.inactive_anon != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.inactive_anon);
        }
        if self.active_anon != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.active_anon);
        }
        if self.inactive_file != 0 {
            my_size += ::protobuf::rt::uint64_size(13, self.inactive_file);
        }
        if self.active_file != 0 {
            my_size += ::protobuf::rt::uint64_size(14, self.active_file);
        }
        if self.unevictable != 0 {
            my_size += ::protobuf::rt::uint64_size(15, self.unevictable);
        }
        if self.hierarchical_memory_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(16, self.hierarchical_memory_limit);
        }
        if self.hierarchical_swap_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(17, self.hierarchical_swap_limit);
        }
        if self.total_cache != 0 {
            my_size += ::protobuf::rt::uint64_size(18, self.total_cache);
        }
        if self.total_rss != 0 {
            my_size += ::protobuf::rt::uint64_size(19, self.total_rss);
        }
        if self.total_rss_huge != 0 {
            my_size += ::protobuf::rt::uint64_size(20, self.total_rss_huge);
        }
        if self.total_mapped_file != 0 {
            my_size += ::protobuf::rt::uint64_size(21, self.total_mapped_file);
        }
        if self.total_dirty != 0 {
            my_size += ::protobuf::rt::uint64_size(22, self.total_dirty);
        }
        if self.total_writeback != 0 {
            my_size += ::protobuf::rt::uint64_size(23, self.total_writeback);
        }
        if self.total_pg_pg_in != 0 {
            my_size += ::protobuf::rt::uint64_size(24, self.total_pg_pg_in);
        }
        if self.total_pg_pg_out != 0 {
            my_size += ::protobuf::rt::uint64_size(25, self.total_pg_pg_out);
        }
        if self.total_pg_fault != 0 {
            my_size += ::protobuf::rt::uint64_size(26, self.total_pg_fault);
        }
        if self.total_pg_maj_fault != 0 {
            my_size += ::protobuf::rt::uint64_size(27, self.total_pg_maj_fault);
        }
        if self.total_inactive_anon != 0 {
            my_size += ::protobuf::rt::uint64_size(28, self.total_inactive_anon);
        }
        if self.total_active_anon != 0 {
            my_size += ::protobuf::rt::uint64_size(29, self.total_active_anon);
        }
        if self.total_inactive_file != 0 {
            my_size += ::protobuf::rt::uint64_size(30, self.total_inactive_file);
        }
        if self.total_active_file != 0 {
            my_size += ::protobuf::rt::uint64_size(31, self.total_active_file);
        }
        if self.total_unevictable != 0 {
            my_size += ::protobuf::rt::uint64_size(32, self.total_unevictable);
        }
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.swap.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.kernel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.kernel_tcp.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cache != 0 {
            os.write_uint64(1, self.cache)?;
        }
        if self.rss != 0 {
            os.write_uint64(2, self.rss)?;
        }
        if self.rss_huge != 0 {
            os.write_uint64(3, self.rss_huge)?;
        }
        if self.mapped_file != 0 {
            os.write_uint64(4, self.mapped_file)?;
        }
        if self.dirty != 0 {
            os.write_uint64(5, self.dirty)?;
        }
        if self.writeback != 0 {
            os.write_uint64(6, self.writeback)?;
        }
        if self.pg_pg_in != 0 {
            os.write_uint64(7, self.pg_pg_in)?;
        }
        if self.pg_pg_out != 0 {
            os.write_uint64(8, self.pg_pg_out)?;
        }
        if self.pg_fault != 0 {
            os.write_uint64(9, self.pg_fault)?;
        }
        if self.pg_maj_fault != 0 {
            os.write_uint64(10, self.pg_maj_fault)?;
        }
        if self.inactive_anon != 0 {
            os.write_uint64(11, self.inactive_anon)?;
        }
        if self.active_anon != 0 {
            os.write_uint64(12, self.active_anon)?;
        }
        if self.inactive_file != 0 {
            os.write_uint64(13, self.inactive_file)?;
        }
        if self.active_file != 0 {
            os.write_uint64(14, self.active_file)?;
        }
        if self.unevictable != 0 {
            os.write_uint64(15, self.unevictable)?;
        }
        if self.hierarchical_memory_limit != 0 {
            os.write_uint64(16, self.hierarchical_memory_limit)?;
        }
        if self.hierarchical_swap_limit != 0 {
            os.write_uint64(17, self.hierarchical_swap_limit)?;
        }
        if self.total_cache != 0 {
            os.write_uint64(18, self.total_cache)?;
        }
        if self.total_rss != 0 {
            os.write_uint64(19, self.total_rss)?;
        }
        if self.total_rss_huge != 0 {
            os.write_uint64(20, self.total_rss_huge)?;
        }
        if self.total_mapped_file != 0 {
            os.write_uint64(21, self.total_mapped_file)?;
        }
        if self.total_dirty != 0 {
            os.write_uint64(22, self.total_dirty)?;
        }
        if self.total_writeback != 0 {
            os.write_uint64(23, self.total_writeback)?;
        }
        if self.total_pg_pg_in != 0 {
            os.write_uint64(24, self.total_pg_pg_in)?;
        }
        if self.total_pg_pg_out != 0 {
            os.write_uint64(25, self.total_pg_pg_out)?;
        }
        if self.total_pg_fault != 0 {
            os.write_uint64(26, self.total_pg_fault)?;
        }
        if self.total_pg_maj_fault != 0 {
            os.write_uint64(27, self.total_pg_maj_fault)?;
        }
        if self.total_inactive_anon != 0 {
            os.write_uint64(28, self.total_inactive_anon)?;
        }
        if self.total_active_anon != 0 {
            os.write_uint64(29, self.total_active_anon)?;
        }
        if self.total_inactive_file != 0 {
            os.write_uint64(30, self.total_inactive_file)?;
        }
        if self.total_active_file != 0 {
            os.write_uint64(31, self.total_active_file)?;
        }
        if self.total_unevictable != 0 {
            os.write_uint64(32, self.total_unevictable)?;
        }
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.swap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.kernel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.kernel_tcp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemoryStat {
        MemoryStat::new()
    }

    fn clear(&mut self) {
        self.cache = 0;
        self.rss = 0;
        self.rss_huge = 0;
        self.mapped_file = 0;
        self.dirty = 0;
        self.writeback = 0;
        self.pg_pg_in = 0;
        self.pg_pg_out = 0;
        self.pg_fault = 0;
        self.pg_maj_fault = 0;
        self.inactive_anon = 0;
        self.active_anon = 0;
        self.inactive_file = 0;
        self.active_file = 0;
        self.unevictable = 0;
        self.hierarchical_memory_limit = 0;
        self.hierarchical_swap_limit = 0;
        self.total_cache = 0;
        self.total_rss = 0;
        self.total_rss_huge = 0;
        self.total_mapped_file = 0;
        self.total_dirty = 0;
        self.total_writeback = 0;
        self.total_pg_pg_in = 0;
        self.total_pg_pg_out = 0;
        self.total_pg_fault = 0;
        self.total_pg_maj_fault = 0;
        self.total_inactive_anon = 0;
        self.total_active_anon = 0;
        self.total_inactive_file = 0;
        self.total_active_file = 0;
        self.total_unevictable = 0;
        self.usage.clear();
        self.swap.clear();
        self.kernel.clear();
        self.kernel_tcp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemoryStat {
        static instance: MemoryStat = MemoryStat {
            cache: 0,
            rss: 0,
            rss_huge: 0,
            mapped_file: 0,
            dirty: 0,
            writeback: 0,
            pg_pg_in: 0,
            pg_pg_out: 0,
            pg_fault: 0,
            pg_maj_fault: 0,
            inactive_anon: 0,
            active_anon: 0,
            inactive_file: 0,
            active_file: 0,
            unevictable: 0,
            hierarchical_memory_limit: 0,
            hierarchical_swap_limit: 0,
            total_cache: 0,
            total_rss: 0,
            total_rss_huge: 0,
            total_mapped_file: 0,
            total_dirty: 0,
            total_writeback: 0,
            total_pg_pg_in: 0,
            total_pg_pg_out: 0,
            total_pg_fault: 0,
            total_pg_maj_fault: 0,
            total_inactive_anon: 0,
            total_active_anon: 0,
            total_inactive_file: 0,
            total_active_file: 0,
            total_unevictable: 0,
            usage: ::protobuf::MessageField::none(),
            swap: ::protobuf::MessageField::none(),
            kernel: ::protobuf::MessageField::none(),
            kernel_tcp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemoryStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemoryStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemoryStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.MemoryEntry)
pub struct MemoryEntry {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryEntry.limit)
    pub limit: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryEntry.usage)
    pub usage: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryEntry.max)
    pub max: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryEntry.failcnt)
    pub failcnt: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.MemoryEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemoryEntry {
    fn default() -> &'a MemoryEntry {
        <MemoryEntry as ::protobuf::Message>::default_instance()
    }
}

impl MemoryEntry {
    pub fn new() -> MemoryEntry {
        ::std::default::Default::default()
    }

    // uint64 limit = 1;

    pub fn limit(&self) -> u64 {
        self.limit
    }

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // uint64 usage = 2;

    pub fn usage(&self) -> u64 {
        self.usage
    }

    pub fn clear_usage(&mut self) {
        self.usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u64) {
        self.usage = v;
    }

    // uint64 max = 3;

    pub fn max(&self) -> u64 {
        self.max
    }

    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u64) {
        self.max = v;
    }

    // uint64 failcnt = 4;

    pub fn failcnt(&self) -> u64 {
        self.failcnt
    }

    pub fn clear_failcnt(&mut self) {
        self.failcnt = 0;
    }

    // Param is passed by value, moved
    pub fn set_failcnt(&mut self, v: u64) {
        self.failcnt = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &MemoryEntry| { &m.limit },
            |m: &mut MemoryEntry| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &MemoryEntry| { &m.usage },
            |m: &mut MemoryEntry| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max",
            |m: &MemoryEntry| { &m.max },
            |m: &mut MemoryEntry| { &mut m.max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failcnt",
            |m: &MemoryEntry| { &m.failcnt },
            |m: &mut MemoryEntry| { &mut m.failcnt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryEntry>(
            "MemoryEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemoryEntry {
    const NAME: &'static str = "MemoryEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_uint64()?;
                },
                16 => {
                    self.usage = is.read_uint64()?;
                },
                24 => {
                    self.max = is.read_uint64()?;
                },
                32 => {
                    self.failcnt = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.limit);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.usage);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.max);
        }
        if self.failcnt != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.failcnt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_uint64(1, self.limit)?;
        }
        if self.usage != 0 {
            os.write_uint64(2, self.usage)?;
        }
        if self.max != 0 {
            os.write_uint64(3, self.max)?;
        }
        if self.failcnt != 0 {
            os.write_uint64(4, self.failcnt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemoryEntry {
        MemoryEntry::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.usage = 0;
        self.max = 0;
        self.failcnt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemoryEntry {
        static instance: MemoryEntry = MemoryEntry {
            limit: 0,
            usage: 0,
            max: 0,
            failcnt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemoryEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemoryEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemoryEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.MemoryOomControl)
pub struct MemoryOomControl {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryOomControl.oom_kill_disable)
    pub oom_kill_disable: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryOomControl.under_oom)
    pub under_oom: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.MemoryOomControl.oom_kill)
    pub oom_kill: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.MemoryOomControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemoryOomControl {
    fn default() -> &'a MemoryOomControl {
        <MemoryOomControl as ::protobuf::Message>::default_instance()
    }
}

impl MemoryOomControl {
    pub fn new() -> MemoryOomControl {
        ::std::default::Default::default()
    }

    // uint64 oom_kill_disable = 1;

    pub fn oom_kill_disable(&self) -> u64 {
        self.oom_kill_disable
    }

    pub fn clear_oom_kill_disable(&mut self) {
        self.oom_kill_disable = 0;
    }

    // Param is passed by value, moved
    pub fn set_oom_kill_disable(&mut self, v: u64) {
        self.oom_kill_disable = v;
    }

    // uint64 under_oom = 2;

    pub fn under_oom(&self) -> u64 {
        self.under_oom
    }

    pub fn clear_under_oom(&mut self) {
        self.under_oom = 0;
    }

    // Param is passed by value, moved
    pub fn set_under_oom(&mut self, v: u64) {
        self.under_oom = v;
    }

    // uint64 oom_kill = 3;

    pub fn oom_kill(&self) -> u64 {
        self.oom_kill
    }

    pub fn clear_oom_kill(&mut self) {
        self.oom_kill = 0;
    }

    // Param is passed by value, moved
    pub fn set_oom_kill(&mut self, v: u64) {
        self.oom_kill = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oom_kill_disable",
            |m: &MemoryOomControl| { &m.oom_kill_disable },
            |m: &mut MemoryOomControl| { &mut m.oom_kill_disable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "under_oom",
            |m: &MemoryOomControl| { &m.under_oom },
            |m: &mut MemoryOomControl| { &mut m.under_oom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oom_kill",
            |m: &MemoryOomControl| { &m.oom_kill },
            |m: &mut MemoryOomControl| { &mut m.oom_kill },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryOomControl>(
            "MemoryOomControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemoryOomControl {
    const NAME: &'static str = "MemoryOomControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.oom_kill_disable = is.read_uint64()?;
                },
                16 => {
                    self.under_oom = is.read_uint64()?;
                },
                24 => {
                    self.oom_kill = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.oom_kill_disable != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.oom_kill_disable);
        }
        if self.under_oom != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.under_oom);
        }
        if self.oom_kill != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.oom_kill);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.oom_kill_disable != 0 {
            os.write_uint64(1, self.oom_kill_disable)?;
        }
        if self.under_oom != 0 {
            os.write_uint64(2, self.under_oom)?;
        }
        if self.oom_kill != 0 {
            os.write_uint64(3, self.oom_kill)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemoryOomControl {
        MemoryOomControl::new()
    }

    fn clear(&mut self) {
        self.oom_kill_disable = 0;
        self.under_oom = 0;
        self.oom_kill = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemoryOomControl {
        static instance: MemoryOomControl = MemoryOomControl {
            oom_kill_disable: 0,
            under_oom: 0,
            oom_kill: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemoryOomControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemoryOomControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemoryOomControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemoryOomControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.BlkIOStat)
pub struct BlkIOStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_service_bytes_recursive)
    pub io_service_bytes_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_serviced_recursive)
    pub io_serviced_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_queued_recursive)
    pub io_queued_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_service_time_recursive)
    pub io_service_time_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_wait_time_recursive)
    pub io_wait_time_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_merged_recursive)
    pub io_merged_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.io_time_recursive)
    pub io_time_recursive: ::std::vec::Vec<BlkIOEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOStat.sectors_recursive)
    pub sectors_recursive: ::std::vec::Vec<BlkIOEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.BlkIOStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlkIOStat {
    fn default() -> &'a BlkIOStat {
        <BlkIOStat as ::protobuf::Message>::default_instance()
    }
}

impl BlkIOStat {
    pub fn new() -> BlkIOStat {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_service_bytes_recursive = 1;

    pub fn io_service_bytes_recursive(&self) -> &[BlkIOEntry] {
        &self.io_service_bytes_recursive
    }

    pub fn clear_io_service_bytes_recursive(&mut self) {
        self.io_service_bytes_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_bytes_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_service_bytes_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_bytes_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_service_bytes_recursive
    }

    // Take field
    pub fn take_io_service_bytes_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_service_bytes_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_serviced_recursive = 2;

    pub fn io_serviced_recursive(&self) -> &[BlkIOEntry] {
        &self.io_serviced_recursive
    }

    pub fn clear_io_serviced_recursive(&mut self) {
        self.io_serviced_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_serviced_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_serviced_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_serviced_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_serviced_recursive
    }

    // Take field
    pub fn take_io_serviced_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_serviced_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_queued_recursive = 3;

    pub fn io_queued_recursive(&self) -> &[BlkIOEntry] {
        &self.io_queued_recursive
    }

    pub fn clear_io_queued_recursive(&mut self) {
        self.io_queued_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_queued_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_queued_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_queued_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_queued_recursive
    }

    // Take field
    pub fn take_io_queued_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_queued_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_service_time_recursive = 4;

    pub fn io_service_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_service_time_recursive
    }

    pub fn clear_io_service_time_recursive(&mut self) {
        self.io_service_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_service_time_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_service_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_service_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_service_time_recursive
    }

    // Take field
    pub fn take_io_service_time_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_service_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_wait_time_recursive = 5;

    pub fn io_wait_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_wait_time_recursive
    }

    pub fn clear_io_wait_time_recursive(&mut self) {
        self.io_wait_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_wait_time_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_wait_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_wait_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_wait_time_recursive
    }

    // Take field
    pub fn take_io_wait_time_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_wait_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_merged_recursive = 6;

    pub fn io_merged_recursive(&self) -> &[BlkIOEntry] {
        &self.io_merged_recursive
    }

    pub fn clear_io_merged_recursive(&mut self) {
        self.io_merged_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_merged_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_merged_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_merged_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_merged_recursive
    }

    // Take field
    pub fn take_io_merged_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_merged_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry io_time_recursive = 7;

    pub fn io_time_recursive(&self) -> &[BlkIOEntry] {
        &self.io_time_recursive
    }

    pub fn clear_io_time_recursive(&mut self) {
        self.io_time_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_io_time_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.io_time_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_io_time_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.io_time_recursive
    }

    // Take field
    pub fn take_io_time_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.io_time_recursive, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.BlkIOEntry sectors_recursive = 8;

    pub fn sectors_recursive(&self) -> &[BlkIOEntry] {
        &self.sectors_recursive
    }

    pub fn clear_sectors_recursive(&mut self) {
        self.sectors_recursive.clear();
    }

    // Param is passed by value, moved
    pub fn set_sectors_recursive(&mut self, v: ::std::vec::Vec<BlkIOEntry>) {
        self.sectors_recursive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sectors_recursive(&mut self) -> &mut ::std::vec::Vec<BlkIOEntry> {
        &mut self.sectors_recursive
    }

    // Take field
    pub fn take_sectors_recursive(&mut self) -> ::std::vec::Vec<BlkIOEntry> {
        ::std::mem::replace(&mut self.sectors_recursive, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_service_bytes_recursive",
            |m: &BlkIOStat| { &m.io_service_bytes_recursive },
            |m: &mut BlkIOStat| { &mut m.io_service_bytes_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_serviced_recursive",
            |m: &BlkIOStat| { &m.io_serviced_recursive },
            |m: &mut BlkIOStat| { &mut m.io_serviced_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_queued_recursive",
            |m: &BlkIOStat| { &m.io_queued_recursive },
            |m: &mut BlkIOStat| { &mut m.io_queued_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_service_time_recursive",
            |m: &BlkIOStat| { &m.io_service_time_recursive },
            |m: &mut BlkIOStat| { &mut m.io_service_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_wait_time_recursive",
            |m: &BlkIOStat| { &m.io_wait_time_recursive },
            |m: &mut BlkIOStat| { &mut m.io_wait_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_merged_recursive",
            |m: &BlkIOStat| { &m.io_merged_recursive },
            |m: &mut BlkIOStat| { &mut m.io_merged_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "io_time_recursive",
            |m: &BlkIOStat| { &m.io_time_recursive },
            |m: &mut BlkIOStat| { &mut m.io_time_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sectors_recursive",
            |m: &BlkIOStat| { &m.sectors_recursive },
            |m: &mut BlkIOStat| { &mut m.sectors_recursive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlkIOStat>(
            "BlkIOStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlkIOStat {
    const NAME: &'static str = "BlkIOStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.io_service_bytes_recursive.push(is.read_message()?);
                },
                18 => {
                    self.io_serviced_recursive.push(is.read_message()?);
                },
                26 => {
                    self.io_queued_recursive.push(is.read_message()?);
                },
                34 => {
                    self.io_service_time_recursive.push(is.read_message()?);
                },
                42 => {
                    self.io_wait_time_recursive.push(is.read_message()?);
                },
                50 => {
                    self.io_merged_recursive.push(is.read_message()?);
                },
                58 => {
                    self.io_time_recursive.push(is.read_message()?);
                },
                66 => {
                    self.sectors_recursive.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.io_service_bytes_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_serviced_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_queued_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_service_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_wait_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_merged_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.io_time_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sectors_recursive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.io_service_bytes_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.io_serviced_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.io_queued_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.io_service_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.io_wait_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.io_merged_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.io_time_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.sectors_recursive {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlkIOStat {
        BlkIOStat::new()
    }

    fn clear(&mut self) {
        self.io_service_bytes_recursive.clear();
        self.io_serviced_recursive.clear();
        self.io_queued_recursive.clear();
        self.io_service_time_recursive.clear();
        self.io_wait_time_recursive.clear();
        self.io_merged_recursive.clear();
        self.io_time_recursive.clear();
        self.sectors_recursive.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlkIOStat {
        static instance: BlkIOStat = BlkIOStat {
            io_service_bytes_recursive: ::std::vec::Vec::new(),
            io_serviced_recursive: ::std::vec::Vec::new(),
            io_queued_recursive: ::std::vec::Vec::new(),
            io_service_time_recursive: ::std::vec::Vec::new(),
            io_wait_time_recursive: ::std::vec::Vec::new(),
            io_merged_recursive: ::std::vec::Vec::new(),
            io_time_recursive: ::std::vec::Vec::new(),
            sectors_recursive: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlkIOStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlkIOStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlkIOStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkIOStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.BlkIOEntry)
pub struct BlkIOEntry {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOEntry.op)
    pub op: ::std::string::String,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOEntry.device)
    pub device: ::std::string::String,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOEntry.major)
    pub major: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOEntry.minor)
    pub minor: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.BlkIOEntry.value)
    pub value: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.BlkIOEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlkIOEntry {
    fn default() -> &'a BlkIOEntry {
        <BlkIOEntry as ::protobuf::Message>::default_instance()
    }
}

impl BlkIOEntry {
    pub fn new() -> BlkIOEntry {
        ::std::default::Default::default()
    }

    // string op = 1;

    pub fn op(&self) -> &str {
        &self.op
    }

    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // string device = 2;

    pub fn device(&self) -> &str {
        &self.device
    }

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // uint64 major = 3;

    pub fn major(&self) -> u64 {
        self.major
    }

    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u64) {
        self.major = v;
    }

    // uint64 minor = 4;

    pub fn minor(&self) -> u64 {
        self.minor
    }

    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u64) {
        self.minor = v;
    }

    // uint64 value = 5;

    pub fn value(&self) -> u64 {
        self.value
    }

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op",
            |m: &BlkIOEntry| { &m.op },
            |m: &mut BlkIOEntry| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device",
            |m: &BlkIOEntry| { &m.device },
            |m: &mut BlkIOEntry| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "major",
            |m: &BlkIOEntry| { &m.major },
            |m: &mut BlkIOEntry| { &mut m.major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minor",
            |m: &BlkIOEntry| { &m.minor },
            |m: &mut BlkIOEntry| { &mut m.minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &BlkIOEntry| { &m.value },
            |m: &mut BlkIOEntry| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlkIOEntry>(
            "BlkIOEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlkIOEntry {
    const NAME: &'static str = "BlkIOEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.op = is.read_string()?;
                },
                18 => {
                    self.device = is.read_string()?;
                },
                24 => {
                    self.major = is.read_uint64()?;
                },
                32 => {
                    self.minor = is.read_uint64()?;
                },
                40 => {
                    self.value = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device);
        }
        if self.major != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.major);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.minor);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.op.is_empty() {
            os.write_string(1, &self.op)?;
        }
        if !self.device.is_empty() {
            os.write_string(2, &self.device)?;
        }
        if self.major != 0 {
            os.write_uint64(3, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint64(4, self.minor)?;
        }
        if self.value != 0 {
            os.write_uint64(5, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlkIOEntry {
        BlkIOEntry::new()
    }

    fn clear(&mut self) {
        self.op.clear();
        self.device.clear();
        self.major = 0;
        self.minor = 0;
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlkIOEntry {
        static instance: BlkIOEntry = BlkIOEntry {
            op: ::std::string::String::new(),
            device: ::std::string::String::new(),
            major: 0,
            minor: 0,
            value: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlkIOEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlkIOEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlkIOEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlkIOEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.RdmaStat)
pub struct RdmaStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.RdmaStat.current)
    pub current: ::std::vec::Vec<RdmaEntry>,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.RdmaStat.limit)
    pub limit: ::std::vec::Vec<RdmaEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.RdmaStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RdmaStat {
    fn default() -> &'a RdmaStat {
        <RdmaStat as ::protobuf::Message>::default_instance()
    }
}

impl RdmaStat {
    pub fn new() -> RdmaStat {
        ::std::default::Default::default()
    }

    // repeated .io.containerd.cgroups.v1.RdmaEntry current = 1;

    pub fn current(&self) -> &[RdmaEntry] {
        &self.current
    }

    pub fn clear_current(&mut self) {
        self.current.clear();
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: ::std::vec::Vec<RdmaEntry>) {
        self.current = v;
    }

    // Mutable pointer to the field.
    pub fn mut_current(&mut self) -> &mut ::std::vec::Vec<RdmaEntry> {
        &mut self.current
    }

    // Take field
    pub fn take_current(&mut self) -> ::std::vec::Vec<RdmaEntry> {
        ::std::mem::replace(&mut self.current, ::std::vec::Vec::new())
    }

    // repeated .io.containerd.cgroups.v1.RdmaEntry limit = 2;

    pub fn limit(&self) -> &[RdmaEntry] {
        &self.limit
    }

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::std::vec::Vec<RdmaEntry>) {
        self.limit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limit(&mut self) -> &mut ::std::vec::Vec<RdmaEntry> {
        &mut self.limit
    }

    // Take field
    pub fn take_limit(&mut self) -> ::std::vec::Vec<RdmaEntry> {
        ::std::mem::replace(&mut self.limit, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "current",
            |m: &RdmaStat| { &m.current },
            |m: &mut RdmaStat| { &mut m.current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "limit",
            |m: &RdmaStat| { &m.limit },
            |m: &mut RdmaStat| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RdmaStat>(
            "RdmaStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RdmaStat {
    const NAME: &'static str = "RdmaStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.current.push(is.read_message()?);
                },
                18 => {
                    self.limit.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.current {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.limit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.current {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.limit {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RdmaStat {
        RdmaStat::new()
    }

    fn clear(&mut self) {
        self.current.clear();
        self.limit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RdmaStat {
        static instance: RdmaStat = RdmaStat {
            current: ::std::vec::Vec::new(),
            limit: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RdmaStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RdmaStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RdmaStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RdmaStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.RdmaEntry)
pub struct RdmaEntry {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.RdmaEntry.device)
    pub device: ::std::string::String,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.RdmaEntry.hca_handles)
    pub hca_handles: u32,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.RdmaEntry.hca_objects)
    pub hca_objects: u32,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.RdmaEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RdmaEntry {
    fn default() -> &'a RdmaEntry {
        <RdmaEntry as ::protobuf::Message>::default_instance()
    }
}

impl RdmaEntry {
    pub fn new() -> RdmaEntry {
        ::std::default::Default::default()
    }

    // string device = 1;

    pub fn device(&self) -> &str {
        &self.device
    }

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // uint32 hca_handles = 2;

    pub fn hca_handles(&self) -> u32 {
        self.hca_handles
    }

    pub fn clear_hca_handles(&mut self) {
        self.hca_handles = 0;
    }

    // Param is passed by value, moved
    pub fn set_hca_handles(&mut self, v: u32) {
        self.hca_handles = v;
    }

    // uint32 hca_objects = 3;

    pub fn hca_objects(&self) -> u32 {
        self.hca_objects
    }

    pub fn clear_hca_objects(&mut self) {
        self.hca_objects = 0;
    }

    // Param is passed by value, moved
    pub fn set_hca_objects(&mut self, v: u32) {
        self.hca_objects = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device",
            |m: &RdmaEntry| { &m.device },
            |m: &mut RdmaEntry| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hca_handles",
            |m: &RdmaEntry| { &m.hca_handles },
            |m: &mut RdmaEntry| { &mut m.hca_handles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hca_objects",
            |m: &RdmaEntry| { &m.hca_objects },
            |m: &mut RdmaEntry| { &mut m.hca_objects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RdmaEntry>(
            "RdmaEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RdmaEntry {
    const NAME: &'static str = "RdmaEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device = is.read_string()?;
                },
                16 => {
                    self.hca_handles = is.read_uint32()?;
                },
                24 => {
                    self.hca_objects = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if self.hca_handles != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.hca_handles);
        }
        if self.hca_objects != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.hca_objects);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if self.hca_handles != 0 {
            os.write_uint32(2, self.hca_handles)?;
        }
        if self.hca_objects != 0 {
            os.write_uint32(3, self.hca_objects)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RdmaEntry {
        RdmaEntry::new()
    }

    fn clear(&mut self) {
        self.device.clear();
        self.hca_handles = 0;
        self.hca_objects = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RdmaEntry {
        static instance: RdmaEntry = RdmaEntry {
            device: ::std::string::String::new(),
            hca_handles: 0,
            hca_objects: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RdmaEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RdmaEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RdmaEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RdmaEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.NetworkStat)
pub struct NetworkStat {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.rx_bytes)
    pub rx_bytes: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.rx_packets)
    pub rx_packets: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.rx_errors)
    pub rx_errors: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.rx_dropped)
    pub rx_dropped: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.tx_bytes)
    pub tx_bytes: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.tx_packets)
    pub tx_packets: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.tx_errors)
    pub tx_errors: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.NetworkStat.tx_dropped)
    pub tx_dropped: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.NetworkStat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkStat {
    fn default() -> &'a NetworkStat {
        <NetworkStat as ::protobuf::Message>::default_instance()
    }
}

impl NetworkStat {
    pub fn new() -> NetworkStat {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 rx_bytes = 2;

    pub fn rx_bytes(&self) -> u64 {
        self.rx_bytes
    }

    pub fn clear_rx_bytes(&mut self) {
        self.rx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_bytes(&mut self, v: u64) {
        self.rx_bytes = v;
    }

    // uint64 rx_packets = 3;

    pub fn rx_packets(&self) -> u64 {
        self.rx_packets
    }

    pub fn clear_rx_packets(&mut self) {
        self.rx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets(&mut self, v: u64) {
        self.rx_packets = v;
    }

    // uint64 rx_errors = 4;

    pub fn rx_errors(&self) -> u64 {
        self.rx_errors
    }

    pub fn clear_rx_errors(&mut self) {
        self.rx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_errors(&mut self, v: u64) {
        self.rx_errors = v;
    }

    // uint64 rx_dropped = 5;

    pub fn rx_dropped(&self) -> u64 {
        self.rx_dropped
    }

    pub fn clear_rx_dropped(&mut self) {
        self.rx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dropped(&mut self, v: u64) {
        self.rx_dropped = v;
    }

    // uint64 tx_bytes = 6;

    pub fn tx_bytes(&self) -> u64 {
        self.tx_bytes
    }

    pub fn clear_tx_bytes(&mut self) {
        self.tx_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_bytes(&mut self, v: u64) {
        self.tx_bytes = v;
    }

    // uint64 tx_packets = 7;

    pub fn tx_packets(&self) -> u64 {
        self.tx_packets
    }

    pub fn clear_tx_packets(&mut self) {
        self.tx_packets = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets(&mut self, v: u64) {
        self.tx_packets = v;
    }

    // uint64 tx_errors = 8;

    pub fn tx_errors(&self) -> u64 {
        self.tx_errors
    }

    pub fn clear_tx_errors(&mut self) {
        self.tx_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_errors(&mut self, v: u64) {
        self.tx_errors = v;
    }

    // uint64 tx_dropped = 9;

    pub fn tx_dropped(&self) -> u64 {
        self.tx_dropped
    }

    pub fn clear_tx_dropped(&mut self) {
        self.tx_dropped = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_dropped(&mut self, v: u64) {
        self.tx_dropped = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &NetworkStat| { &m.name },
            |m: &mut NetworkStat| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_bytes",
            |m: &NetworkStat| { &m.rx_bytes },
            |m: &mut NetworkStat| { &mut m.rx_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_packets",
            |m: &NetworkStat| { &m.rx_packets },
            |m: &mut NetworkStat| { &mut m.rx_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_errors",
            |m: &NetworkStat| { &m.rx_errors },
            |m: &mut NetworkStat| { &mut m.rx_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rx_dropped",
            |m: &NetworkStat| { &m.rx_dropped },
            |m: &mut NetworkStat| { &mut m.rx_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_bytes",
            |m: &NetworkStat| { &m.tx_bytes },
            |m: &mut NetworkStat| { &mut m.tx_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_packets",
            |m: &NetworkStat| { &m.tx_packets },
            |m: &mut NetworkStat| { &mut m.tx_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_errors",
            |m: &NetworkStat| { &m.tx_errors },
            |m: &mut NetworkStat| { &mut m.tx_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_dropped",
            |m: &NetworkStat| { &m.tx_dropped },
            |m: &mut NetworkStat| { &mut m.tx_dropped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkStat>(
            "NetworkStat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkStat {
    const NAME: &'static str = "NetworkStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.rx_bytes = is.read_uint64()?;
                },
                24 => {
                    self.rx_packets = is.read_uint64()?;
                },
                32 => {
                    self.rx_errors = is.read_uint64()?;
                },
                40 => {
                    self.rx_dropped = is.read_uint64()?;
                },
                48 => {
                    self.tx_bytes = is.read_uint64()?;
                },
                56 => {
                    self.tx_packets = is.read_uint64()?;
                },
                64 => {
                    self.tx_errors = is.read_uint64()?;
                },
                72 => {
                    self.tx_dropped = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.rx_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.rx_bytes);
        }
        if self.rx_packets != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.rx_packets);
        }
        if self.rx_errors != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.rx_errors);
        }
        if self.rx_dropped != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.rx_dropped);
        }
        if self.tx_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.tx_bytes);
        }
        if self.tx_packets != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.tx_packets);
        }
        if self.tx_errors != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.tx_errors);
        }
        if self.tx_dropped != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.tx_dropped);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.rx_bytes != 0 {
            os.write_uint64(2, self.rx_bytes)?;
        }
        if self.rx_packets != 0 {
            os.write_uint64(3, self.rx_packets)?;
        }
        if self.rx_errors != 0 {
            os.write_uint64(4, self.rx_errors)?;
        }
        if self.rx_dropped != 0 {
            os.write_uint64(5, self.rx_dropped)?;
        }
        if self.tx_bytes != 0 {
            os.write_uint64(6, self.tx_bytes)?;
        }
        if self.tx_packets != 0 {
            os.write_uint64(7, self.tx_packets)?;
        }
        if self.tx_errors != 0 {
            os.write_uint64(8, self.tx_errors)?;
        }
        if self.tx_dropped != 0 {
            os.write_uint64(9, self.tx_dropped)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkStat {
        NetworkStat::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.rx_bytes = 0;
        self.rx_packets = 0;
        self.rx_errors = 0;
        self.rx_dropped = 0;
        self.tx_bytes = 0;
        self.tx_packets = 0;
        self.tx_errors = 0;
        self.tx_dropped = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkStat {
        static instance: NetworkStat = NetworkStat {
            name: ::std::string::String::new(),
            rx_bytes: 0,
            rx_packets: 0,
            rx_errors: 0,
            rx_dropped: 0,
            tx_bytes: 0,
            tx_packets: 0,
            tx_errors: 0,
            tx_dropped: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkStat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkStat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkStat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:io.containerd.cgroups.v1.CgroupStats)
pub struct CgroupStats {
    // message fields
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CgroupStats.nr_sleeping)
    pub nr_sleeping: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CgroupStats.nr_running)
    pub nr_running: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CgroupStats.nr_stopped)
    pub nr_stopped: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CgroupStats.nr_uninterruptible)
    pub nr_uninterruptible: u64,
    // @@protoc_insertion_point(field:io.containerd.cgroups.v1.CgroupStats.nr_io_wait)
    pub nr_io_wait: u64,
    // special fields
    // @@protoc_insertion_point(special_field:io.containerd.cgroups.v1.CgroupStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CgroupStats {
    fn default() -> &'a CgroupStats {
        <CgroupStats as ::protobuf::Message>::default_instance()
    }
}

impl CgroupStats {
    pub fn new() -> CgroupStats {
        ::std::default::Default::default()
    }

    // uint64 nr_sleeping = 1;

    pub fn nr_sleeping(&self) -> u64 {
        self.nr_sleeping
    }

    pub fn clear_nr_sleeping(&mut self) {
        self.nr_sleeping = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_sleeping(&mut self, v: u64) {
        self.nr_sleeping = v;
    }

    // uint64 nr_running = 2;

    pub fn nr_running(&self) -> u64 {
        self.nr_running
    }

    pub fn clear_nr_running(&mut self) {
        self.nr_running = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_running(&mut self, v: u64) {
        self.nr_running = v;
    }

    // uint64 nr_stopped = 3;

    pub fn nr_stopped(&self) -> u64 {
        self.nr_stopped
    }

    pub fn clear_nr_stopped(&mut self) {
        self.nr_stopped = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_stopped(&mut self, v: u64) {
        self.nr_stopped = v;
    }

    // uint64 nr_uninterruptible = 4;

    pub fn nr_uninterruptible(&self) -> u64 {
        self.nr_uninterruptible
    }

    pub fn clear_nr_uninterruptible(&mut self) {
        self.nr_uninterruptible = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_uninterruptible(&mut self, v: u64) {
        self.nr_uninterruptible = v;
    }

    // uint64 nr_io_wait = 5;

    pub fn nr_io_wait(&self) -> u64 {
        self.nr_io_wait
    }

    pub fn clear_nr_io_wait(&mut self) {
        self.nr_io_wait = 0;
    }

    // Param is passed by value, moved
    pub fn set_nr_io_wait(&mut self, v: u64) {
        self.nr_io_wait = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nr_sleeping",
            |m: &CgroupStats| { &m.nr_sleeping },
            |m: &mut CgroupStats| { &mut m.nr_sleeping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nr_running",
            |m: &CgroupStats| { &m.nr_running },
            |m: &mut CgroupStats| { &mut m.nr_running },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nr_stopped",
            |m: &CgroupStats| { &m.nr_stopped },
            |m: &mut CgroupStats| { &mut m.nr_stopped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nr_uninterruptible",
            |m: &CgroupStats| { &m.nr_uninterruptible },
            |m: &mut CgroupStats| { &mut m.nr_uninterruptible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nr_io_wait",
            |m: &CgroupStats| { &m.nr_io_wait },
            |m: &mut CgroupStats| { &mut m.nr_io_wait },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CgroupStats>(
            "CgroupStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CgroupStats {
    const NAME: &'static str = "CgroupStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.nr_sleeping = is.read_uint64()?;
                },
                16 => {
                    self.nr_running = is.read_uint64()?;
                },
                24 => {
                    self.nr_stopped = is.read_uint64()?;
                },
                32 => {
                    self.nr_uninterruptible = is.read_uint64()?;
                },
                40 => {
                    self.nr_io_wait = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.nr_sleeping != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.nr_sleeping);
        }
        if self.nr_running != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.nr_running);
        }
        if self.nr_stopped != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.nr_stopped);
        }
        if self.nr_uninterruptible != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.nr_uninterruptible);
        }
        if self.nr_io_wait != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.nr_io_wait);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.nr_sleeping != 0 {
            os.write_uint64(1, self.nr_sleeping)?;
        }
        if self.nr_running != 0 {
            os.write_uint64(2, self.nr_running)?;
        }
        if self.nr_stopped != 0 {
            os.write_uint64(3, self.nr_stopped)?;
        }
        if self.nr_uninterruptible != 0 {
            os.write_uint64(4, self.nr_uninterruptible)?;
        }
        if self.nr_io_wait != 0 {
            os.write_uint64(5, self.nr_io_wait)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CgroupStats {
        CgroupStats::new()
    }

    fn clear(&mut self) {
        self.nr_sleeping = 0;
        self.nr_running = 0;
        self.nr_stopped = 0;
        self.nr_uninterruptible = 0;
        self.nr_io_wait = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CgroupStats {
        static instance: CgroupStats = CgroupStats {
            nr_sleeping: 0,
            nr_running: 0,
            nr_stopped: 0,
            nr_uninterruptible: 0,
            nr_io_wait: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CgroupStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CgroupStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CgroupStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CgroupStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n4github.com/containerd/cgroups/stats/v1/metrics.proto\x12\x18io.contai\
    nerd.cgroups.v1\x1a\x14gogoproto/gogo.proto\"\xd6\x04\n\x07Metrics\x12?\
    \n\x07hugetlb\x18\x01\x20\x03(\x0b2%.io.containerd.cgroups.v1.HugetlbSta\
    tR\x07hugetlb\x126\n\x04pids\x18\x02\x20\x01(\x0b2\".io.containerd.cgrou\
    ps.v1.PidsStatR\x04pids\x12<\n\x03cpu\x18\x03\x20\x01(\x0b2!.io.containe\
    rd.cgroups.v1.CPUStatR\x03cpuB\x07\xe2\xde\x1f\x03CPU\x12<\n\x06memory\
    \x18\x04\x20\x01(\x0b2$.io.containerd.cgroups.v1.MemoryStatR\x06memory\
    \x129\n\x05blkio\x18\x05\x20\x01(\x0b2#.io.containerd.cgroups.v1.BlkIOSt\
    atR\x05blkio\x126\n\x04rdma\x18\x06\x20\x01(\x0b2\".io.containerd.cgroup\
    s.v1.RdmaStatR\x04rdma\x12?\n\x07network\x18\x07\x20\x03(\x0b2%.io.conta\
    inerd.cgroups.v1.NetworkStatR\x07network\x12H\n\x0ccgroup_stats\x18\x08\
    \x20\x01(\x0b2%.io.containerd.cgroups.v1.CgroupStatsR\x0bcgroupStats\x12\
    X\n\x12memory_oom_control\x18\t\x20\x01(\x0b2*.io.containerd.cgroups.v1.\
    MemoryOomControlR\x10memoryOomControl\"k\n\x0bHugetlbStat\x12\x14\n\x05u\
    sage\x18\x01\x20\x01(\x04R\x05usage\x12\x10\n\x03max\x18\x02\x20\x01(\
    \x04R\x03max\x12\x18\n\x07failcnt\x18\x03\x20\x01(\x04R\x07failcnt\x12\
    \x1a\n\x08pagesize\x18\x04\x20\x01(\tR\x08pagesize\":\n\x08PidsStat\x12\
    \x18\n\x07current\x18\x01\x20\x01(\x04R\x07current\x12\x14\n\x05limit\
    \x18\x02\x20\x01(\x04R\x05limit\"\x87\x01\n\x07CPUStat\x128\n\x05usage\
    \x18\x01\x20\x01(\x0b2\".io.containerd.cgroups.v1.CPUUsageR\x05usage\x12\
    B\n\nthrottling\x18\x02\x20\x01(\x0b2\".io.containerd.cgroups.v1.Throttl\
    eR\nthrottling\"q\n\x08CPUUsage\x12\x14\n\x05total\x18\x01\x20\x01(\x04R\
    \x05total\x12\x16\n\x06kernel\x18\x02\x20\x01(\x04R\x06kernel\x12\x12\n\
    \x04user\x18\x03\x20\x01(\x04R\x04user\x12#\n\x07per_cpu\x18\x04\x20\x03\
    (\x04R\x06perCpuB\n\xe2\xde\x1f\x06PerCPU\"x\n\x08Throttle\x12\x18\n\x07\
    periods\x18\x01\x20\x01(\x04R\x07periods\x12+\n\x11throttled_periods\x18\
    \x02\x20\x01(\x04R\x10throttledPeriods\x12%\n\x0ethrottled_time\x18\x03\
    \x20\x01(\x04R\rthrottledTime\"\xd9\x0b\n\nMemoryStat\x12\x14\n\x05cache\
    \x18\x01\x20\x01(\x04R\x05cache\x12\x19\n\x03rss\x18\x02\x20\x01(\x04R\
    \x03rssB\x07\xe2\xde\x1f\x03RSS\x12&\n\x08rss_huge\x18\x03\x20\x01(\x04R\
    \x07rssHugeB\x0b\xe2\xde\x1f\x07RSSHuge\x12\x1f\n\x0bmapped_file\x18\x04\
    \x20\x01(\x04R\nmappedFile\x12\x14\n\x05dirty\x18\x05\x20\x01(\x04R\x05d\
    irty\x12\x1c\n\twriteback\x18\x06\x20\x01(\x04R\twriteback\x12\x18\n\x08\
    pg_pg_in\x18\x07\x20\x01(\x04R\x06pgPgIn\x12\x1a\n\tpg_pg_out\x18\x08\
    \x20\x01(\x04R\x07pgPgOut\x12\x19\n\x08pg_fault\x18\t\x20\x01(\x04R\x07p\
    gFault\x12\x20\n\x0cpg_maj_fault\x18\n\x20\x01(\x04R\npgMajFault\x12#\n\
    \rinactive_anon\x18\x0b\x20\x01(\x04R\x0cinactiveAnon\x12\x1f\n\x0bactiv\
    e_anon\x18\x0c\x20\x01(\x04R\nactiveAnon\x12#\n\rinactive_file\x18\r\x20\
    \x01(\x04R\x0cinactiveFile\x12\x1f\n\x0bactive_file\x18\x0e\x20\x01(\x04\
    R\nactiveFile\x12\x20\n\x0bunevictable\x18\x0f\x20\x01(\x04R\x0bunevicta\
    ble\x12:\n\x19hierarchical_memory_limit\x18\x10\x20\x01(\x04R\x17hierarc\
    hicalMemoryLimit\x126\n\x17hierarchical_swap_limit\x18\x11\x20\x01(\x04R\
    \x15hierarchicalSwapLimit\x12\x1f\n\x0btotal_cache\x18\x12\x20\x01(\x04R\
    \ntotalCache\x12)\n\ttotal_rss\x18\x13\x20\x01(\x04R\x08totalRssB\x0c\
    \xe2\xde\x1f\x08TotalRSS\x126\n\x0etotal_rss_huge\x18\x14\x20\x01(\x04R\
    \x0ctotalRssHugeB\x10\xe2\xde\x1f\x0cTotalRSSHuge\x12*\n\x11total_mapped\
    _file\x18\x15\x20\x01(\x04R\x0ftotalMappedFile\x12\x1f\n\x0btotal_dirty\
    \x18\x16\x20\x01(\x04R\ntotalDirty\x12'\n\x0ftotal_writeback\x18\x17\x20\
    \x01(\x04R\x0etotalWriteback\x12#\n\x0etotal_pg_pg_in\x18\x18\x20\x01(\
    \x04R\x0btotalPgPgIn\x12%\n\x0ftotal_pg_pg_out\x18\x19\x20\x01(\x04R\x0c\
    totalPgPgOut\x12$\n\x0etotal_pg_fault\x18\x1a\x20\x01(\x04R\x0ctotalPgFa\
    ult\x12+\n\x12total_pg_maj_fault\x18\x1b\x20\x01(\x04R\x0ftotalPgMajFaul\
    t\x12.\n\x13total_inactive_anon\x18\x1c\x20\x01(\x04R\x11totalInactiveAn\
    on\x12*\n\x11total_active_anon\x18\x1d\x20\x01(\x04R\x0ftotalActiveAnon\
    \x12.\n\x13total_inactive_file\x18\x1e\x20\x01(\x04R\x11totalInactiveFil\
    e\x12*\n\x11total_active_file\x18\x1f\x20\x01(\x04R\x0ftotalActiveFile\
    \x12+\n\x11total_unevictable\x18\x20\x20\x01(\x04R\x10totalUnevictable\
    \x12;\n\x05usage\x18!\x20\x01(\x0b2%.io.containerd.cgroups.v1.MemoryEntr\
    yR\x05usage\x129\n\x04swap\x18\"\x20\x01(\x0b2%.io.containerd.cgroups.v1\
    .MemoryEntryR\x04swap\x12=\n\x06kernel\x18#\x20\x01(\x0b2%.io.containerd\
    .cgroups.v1.MemoryEntryR\x06kernel\x12S\n\nkernel_tcp\x18$\x20\x01(\x0b2\
    %.io.containerd.cgroups.v1.MemoryEntryR\tkernelTcpB\r\xe2\xde\x1f\tKerne\
    lTCP\"e\n\x0bMemoryEntry\x12\x14\n\x05limit\x18\x01\x20\x01(\x04R\x05lim\
    it\x12\x14\n\x05usage\x18\x02\x20\x01(\x04R\x05usage\x12\x10\n\x03max\
    \x18\x03\x20\x01(\x04R\x03max\x12\x18\n\x07failcnt\x18\x04\x20\x01(\x04R\
    \x07failcnt\"t\n\x10MemoryOomControl\x12(\n\x10oom_kill_disable\x18\x01\
    \x20\x01(\x04R\x0eoomKillDisable\x12\x1b\n\tunder_oom\x18\x02\x20\x01(\
    \x04R\x08underOom\x12\x19\n\x08oom_kill\x18\x03\x20\x01(\x04R\x07oomKill\
    \"\xd5\x05\n\tBlkIOStat\x12a\n\x1aio_service_bytes_recursive\x18\x01\x20\
    \x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x17ioServiceBytesRecurs\
    ive\x12X\n\x15io_serviced_recursive\x18\x02\x20\x03(\x0b2$.io.containerd\
    .cgroups.v1.BlkIOEntryR\x13ioServicedRecursive\x12T\n\x13io_queued_recur\
    sive\x18\x03\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x11ioQu\
    euedRecursive\x12_\n\x19io_service_time_recursive\x18\x04\x20\x03(\x0b2$\
    .io.containerd.cgroups.v1.BlkIOEntryR\x16ioServiceTimeRecursive\x12Y\n\
    \x16io_wait_time_recursive\x18\x05\x20\x03(\x0b2$.io.containerd.cgroups.\
    v1.BlkIOEntryR\x13ioWaitTimeRecursive\x12T\n\x13io_merged_recursive\x18\
    \x06\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x11ioMergedRecu\
    rsive\x12P\n\x11io_time_recursive\x18\x07\x20\x03(\x0b2$.io.containerd.c\
    groups.v1.BlkIOEntryR\x0fioTimeRecursive\x12Q\n\x11sectors_recursive\x18\
    \x08\x20\x03(\x0b2$.io.containerd.cgroups.v1.BlkIOEntryR\x10sectorsRecur\
    sive\"v\n\nBlkIOEntry\x12\x0e\n\x02op\x18\x01\x20\x01(\tR\x02op\x12\x16\
    \n\x06device\x18\x02\x20\x01(\tR\x06device\x12\x14\n\x05major\x18\x03\
    \x20\x01(\x04R\x05major\x12\x14\n\x05minor\x18\x04\x20\x01(\x04R\x05mino\
    r\x12\x14\n\x05value\x18\x05\x20\x01(\x04R\x05value\"\x84\x01\n\x08RdmaS\
    tat\x12=\n\x07current\x18\x01\x20\x03(\x0b2#.io.containerd.cgroups.v1.Rd\
    maEntryR\x07current\x129\n\x05limit\x18\x02\x20\x03(\x0b2#.io.containerd\
    .cgroups.v1.RdmaEntryR\x05limit\"e\n\tRdmaEntry\x12\x16\n\x06device\x18\
    \x01\x20\x01(\tR\x06device\x12\x1f\n\x0bhca_handles\x18\x02\x20\x01(\rR\
    \nhcaHandles\x12\x1f\n\x0bhca_objects\x18\x03\x20\x01(\rR\nhcaObjects\"\
    \x8d\x02\n\x0bNetworkStat\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x19\n\x08rx_bytes\x18\x02\x20\x01(\x04R\x07rxBytes\x12\x1d\n\nrx_pa\
    ckets\x18\x03\x20\x01(\x04R\trxPackets\x12\x1b\n\trx_errors\x18\x04\x20\
    \x01(\x04R\x08rxErrors\x12\x1d\n\nrx_dropped\x18\x05\x20\x01(\x04R\trxDr\
    opped\x12\x19\n\x08tx_bytes\x18\x06\x20\x01(\x04R\x07txBytes\x12\x1d\n\n\
    tx_packets\x18\x07\x20\x01(\x04R\ttxPackets\x12\x1b\n\ttx_errors\x18\x08\
    \x20\x01(\x04R\x08txErrors\x12\x1d\n\ntx_dropped\x18\t\x20\x01(\x04R\ttx\
    Dropped\"\xb9\x01\n\x0bCgroupStats\x12\x1f\n\x0bnr_sleeping\x18\x01\x20\
    \x01(\x04R\nnrSleeping\x12\x1d\n\nnr_running\x18\x02\x20\x01(\x04R\tnrRu\
    nning\x12\x1d\n\nnr_stopped\x18\x03\x20\x01(\x04R\tnrStopped\x12-\n\x12n\
    r_uninterruptible\x18\x04\x20\x01(\x04R\x11nrUninterruptible\x12\x1c\n\n\
    nr_io_wait\x18\x05\x20\x01(\x04R\x08nrIoWaitb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::gogo::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(Metrics::generated_message_descriptor_data());
            messages.push(HugetlbStat::generated_message_descriptor_data());
            messages.push(PidsStat::generated_message_descriptor_data());
            messages.push(CPUStat::generated_message_descriptor_data());
            messages.push(CPUUsage::generated_message_descriptor_data());
            messages.push(Throttle::generated_message_descriptor_data());
            messages.push(MemoryStat::generated_message_descriptor_data());
            messages.push(MemoryEntry::generated_message_descriptor_data());
            messages.push(MemoryOomControl::generated_message_descriptor_data());
            messages.push(BlkIOStat::generated_message_descriptor_data());
            messages.push(BlkIOEntry::generated_message_descriptor_data());
            messages.push(RdmaStat::generated_message_descriptor_data());
            messages.push(RdmaEntry::generated_message_descriptor_data());
            messages.push(NetworkStat::generated_message_descriptor_data());
            messages.push(CgroupStats::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
